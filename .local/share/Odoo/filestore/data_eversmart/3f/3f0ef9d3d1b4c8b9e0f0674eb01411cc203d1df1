)]}'
{"version": 3, "sources": ["/web/static/src/legacy/js/views/graph/graph_controller.js", "/web/static/src/legacy/js/views/graph/graph_model.js", "/web/static/src/legacy/js/views/graph/graph_renderer.js", "/web/static/src/legacy/js/views/graph/graph_utils.js", "/web/static/src/legacy/js/views/graph/graph_view.js", "/web/static/src/legacy/js/views/pivot/pivot_controller.js", "/web/static/src/legacy/js/views/pivot/pivot_model.js", "/web/static/src/legacy/js/views/pivot/pivot_renderer.js", "/web/static/src/legacy/js/views/pivot/pivot_view.js"], "mappings": "AAAA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChWA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3UA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACv+BA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtFA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/KA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClUA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzgDA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnSA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["odoo.define('web.GraphController', function (require) {\n\"use strict\";\n\n/*---------------------------------------------------------\n * Odoo Graph view\n *---------------------------------------------------------*/\n\nconst AbstractController = require('web.AbstractController');\nconst { ComponentWrapper } = require('web.OwlCompatibility');\nconst DropdownMenu = require('web.DropdownMenu');\nconst { DEFAULT_INTERVAL, INTERVAL_OPTIONS } = require('web.searchUtils');\nconst { qweb } = require('web.core');\nconst { _t } = require('web.core');\n\nclass CarretDropdownMenu extends DropdownMenu {\n    /**\n     * @override\n     */\n    get displayCaret() {\n        return true;\n    }\n}\n\nvar GraphController = AbstractController.extend({\n    custom_events: _.extend({}, AbstractController.prototype.custom_events, {\n        item_selected: '_onItemSelected',\n        open_view: '_onOpenView',\n    }),\n\n    /**\n     * @override\n     * @param {Widget} parent\n     * @param {GraphModel} model\n     * @param {GraphRenderer} renderer\n     * @param {Object} params\n     * @param {string[]} params.measures\n     * @param {boolean} params.isEmbedded\n     * @param {string[]} params.groupableFields,\n     */\n    init: function (parent, model, renderer, params) {\n        this._super.apply(this, arguments);\n        this.measures = params.measures;\n        // this parameter condition the appearance of a 'Group By'\n        // button in the control panel owned by the graph view.\n        this.isEmbedded = params.isEmbedded;\n        this.withButtons = params.withButtons;\n        // views to use in the action triggered when the graph is clicked\n        this.views = params.views;\n        this.title = params.title;\n\n        // this parameter determines what is the list of fields\n        // that may be used within the groupby menu available when\n        // the view is embedded\n        this.groupableFields = params.groupableFields;\n        this.buttonDropdownPromises = [];\n    },\n    /**\n     * @todo check if this can be removed (mostly duplicate with\n     * AbstractController method)\n     */\n    destroy: function () {\n        if (this.$buttons) {\n            // remove jquery's tooltip() handlers\n            this.$buttons.find('button').off().tooltip('dispose');\n        }\n        this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns the current mode, measure and groupbys, so we can restore the\n     * view when we save the current state in the search view, or when we add it\n     * to the dashboard.\n     *\n     * @override\n     * @returns {Object}\n     */\n    getOwnedQueryParams: function () {\n        var state = this.model.get();\n        return {\n            context: {\n                graph_measure: state.measure,\n                graph_mode: state.mode,\n                graph_groupbys: state.groupBy,\n            }\n        };\n    },\n    /**\n     * @override\n     */\n    reload: async function () {\n        const promises = [this._super(...arguments)];\n        if (this.withButtons) {\n            const state = this.model.get();\n            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);\n            promises.push(this.measureMenu.update({ items: this.measures }));\n        }\n        return Promise.all(promises);\n    },\n    /**\n     * Render the buttons according to the GraphView.buttons and\n     * add listeners on it.\n     * Set this.$buttons with the produced jQuery element\n     *\n     * @param {jQuery} [$node] a jQuery node where the rendered buttons should\n     * be inserted $node may be undefined, in which case the GraphView does\n     * nothing\n     */\n    renderButtons: function ($node) {\n        this.$buttons = $(qweb.render('GraphView.buttons'));\n        this.$buttons.find('button').tooltip();\n        this.$buttons.click(ev => this._onButtonClick(ev));\n\n        if (this.withButtons) {\n            const state = this.model.get();\n            const fragment = document.createDocumentFragment();\n            // Instantiate and append MeasureMenu\n            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);\n            this.measureMenu = new ComponentWrapper(this, CarretDropdownMenu, {\n                title: _t(\"Measures\"),\n                items: this.measures,\n            });\n            this.buttonDropdownPromises = [this.measureMenu.mount(fragment)];\n            if (this.isEmbedded) {\n                // Instantiate and append GroupBy menu\n                this.groupByMenu = new ComponentWrapper(this, CarretDropdownMenu, {\n                    title: _t(\"Group By\"),\n                    icon: 'fa fa-bars',\n                    items: this._getGroupBys(state.groupBy),\n                });\n                this.buttonDropdownPromises.push(this.groupByMenu.mount(fragment));\n            }\n            if ($node) {\n                this.$buttons.appendTo($node);\n            }\n        }\n    },\n    /**\n     * Makes sure that the buttons in the control panel matches the current\n     * state (so, correct active buttons and stuff like that).\n     *\n     * @override\n     */\n    updateButtons: function () {\n        if (!this.$buttons) {\n            return;\n        }\n        var state = this.model.get();\n        this.$buttons.find('.o_graph_button').removeClass('active');\n        this.$buttons\n            .find('.o_graph_button[data-mode=\"' + state.mode + '\"]')\n            .addClass('active');\n        this.$buttons\n            .find('.o_graph_button[data-mode=\"stack\"]')\n            .data('stacked', state.stacked)\n            .toggleClass('active', state.stacked)\n            .toggleClass('o_hidden', state.mode !== 'bar');\n        this.$buttons\n            .find('.o_graph_button[data-order]')\n            .toggleClass('o_hidden', state.mode === 'pie' || !!Object.keys(state.timeRanges).length)\n            .filter('.o_graph_button[data-order=\"' + state.orderBy + '\"]')\n            .toggleClass('active', !!state.orderBy);\n\n        if (this.withButtons) {\n            return this._attachDropdownComponents();\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Attaches the different dropdown components to the buttons container.\n     *\n     * @returns {Promise}\n     */\n    async _attachDropdownComponents() {\n        await Promise.all(this.buttonDropdownPromises);\n        if (this.isDestroyed()) {\n            return;\n        }\n        const actionsContainer = this.$buttons[0];\n        // Attach \"measures\" button\n        actionsContainer.appendChild(this.measureMenu.el);\n        this.measureMenu.el.classList.add('o_graph_measures_list');\n        if (this.isEmbedded) {\n            // Attach \"groupby\" button\n            actionsContainer.appendChild(this.groupByMenu.el);\n            this.groupByMenu.el.classList.add('o_group_by_menu');\n        }\n        // Update button classes accordingly to the current mode\n        const buttons = actionsContainer.querySelectorAll('.dropdown-toggle');\n        for (const button of buttons) {\n            button.classList.remove('btn-secondary');\n            if (this.isEmbedded) {\n                button.classList.add('btn-outline-secondary');\n            } else {\n                button.classList.add('btn-primary');\n                button.tabIndex = 0;\n            }\n        }\n    },\n\n    /**\n     * Returns the items used by the Group By menu in embedded mode.\n     *\n     * @private\n     * @param {string[]} activeGroupBys\n     * @returns {Object[]}\n     */\n    _getGroupBys(activeGroupBys) {\n        const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);\n        const groupBys = Object.keys(this.groupableFields).map(fieldName => {\n            const field = this.groupableFields[fieldName];\n            const groupByActivity = normalizedGroupBys.filter(gb => gb.fieldName === fieldName);\n            const groupBy = {\n                id: fieldName,\n                isActive: Boolean(groupByActivity.length),\n                description: field.string,\n                itemType: 'groupBy',\n            };\n            if (['date', 'datetime'].includes(field.type)) {\n                groupBy.hasOptions = true;\n                const activeOptionIds = groupByActivity.map(gb => gb.interval);\n                groupBy.options = Object.values(INTERVAL_OPTIONS).map(o => {\n                    return Object.assign({}, o, { isActive: activeOptionIds.includes(o.id) });\n                });\n            }\n            return groupBy;\n        }).sort((gb1, gb2) => {\n            return gb1.description.localeCompare(gb2.description);\n        });\n        return groupBys;\n    },\n\n    /**\n     * This method puts the active groupBys in a convenient form.\n     *\n     * @private\n     * @param {string[]} activeGroupBys\n     * @returns {Object[]} normalizedGroupBys\n     */\n    _normalizeActiveGroupBys(activeGroupBys) {\n        return activeGroupBys.map(groupBy => {\n            const fieldName = groupBy.split(':')[0];\n            const field = this.groupableFields[fieldName];\n            const normalizedGroupBy = { fieldName };\n            if (['date', 'datetime'].includes(field.type)) {\n                normalizedGroupBy.interval = groupBy.split(':')[1] || DEFAULT_INTERVAL;\n            }\n            return normalizedGroupBy;\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Do what need to be done when a button from the control panel is clicked.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onButtonClick: function (ev) {\n        var $target = $(ev.target);\n        if ($target.hasClass('o_graph_button')) {\n            if (_.contains(['bar','line', 'pie'], $target.data('mode'))) {\n                this.update({ mode: $target.data('mode') });\n            } else if ($target.data('mode') === 'stack') {\n                this.update({ stacked: !$target.data('stacked') });\n            } else if (['asc', 'desc'].includes($target.data('order'))) {\n                const order = $target.data('order');\n                const state = this.model.get();\n                this.update({ orderBy: state.orderBy === order ? false : order });\n            }\n        }\n    },\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onItemSelected(ev) {\n        const item = ev.data.item;\n        if (this.isEmbedded && item.itemType === 'groupBy') {\n            const fieldName = item.id;\n            const optionId = ev.data.option && ev.data.option.id;\n            const activeGroupBys = this.model.get().groupBy;\n            if (optionId) {\n                const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);\n                const index = normalizedGroupBys.findIndex(ngb =>\n                    ngb.fieldName === fieldName && ngb.interval === optionId);\n                if (index === -1) {\n                    activeGroupBys.push(fieldName + ':' + optionId);\n                } else {\n                    activeGroupBys.splice(index, 1);\n                }\n            } else {\n                const groupByFieldNames = activeGroupBys.map(gb => gb.split(':')[0]);\n                const indexOfGroupby = groupByFieldNames.indexOf(fieldName);\n                if (indexOfGroupby === -1) {\n                    activeGroupBys.push(fieldName);\n                } else {\n                    activeGroupBys.splice(indexOfGroupby, 1);\n                }\n            }\n            this.update({ groupBy: activeGroupBys });\n            this.groupByMenu.update({\n                items: this._getGroupBys(activeGroupBys),\n            });\n        } else if (item.itemType === 'measure') {\n            this.update({ measure: item.fieldName });\n            this.measures.forEach(m => m.isActive = m.fieldName === item.fieldName);\n            this.measureMenu.update({ items: this.measures });\n        }\n    },\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     * @param {Array[]} ev.data.domain\n     */\n    _onOpenView(ev) {\n        ev.stopPropagation();\n        const state = this.model.get();\n        const context = Object.assign({}, state.context);\n        Object.keys(context).forEach(x => {\n            if (x === 'group_by' || x.startsWith('search_default_')) {\n                delete context[x];\n            }\n        });\n        this.do_action({\n            context: context,\n            domain: ev.data.domain,\n            name: this.title,\n            res_model: this.modelName,\n            target: 'current',\n            type: 'ir.actions.act_window',\n            view_mode: 'list',\n            views: this.views,\n        });\n    },\n});\n\nreturn GraphController;\n\n});\n", "odoo.define('web.GraphModel', function (require) {\n\"use strict\";\n\nvar core = require('web.core');\nconst { DEFAULT_INTERVAL, rankInterval } = require('web.searchUtils');\n\nvar _t = core._t;\n\n/**\n * The graph model is responsible for fetching and processing data from the\n * server.  It basically just do a(some) read_group(s) and format/normalize data.\n */\nvar AbstractModel = require('web.AbstractModel');\n\nreturn AbstractModel.extend({\n    /**\n     * @override\n     * @param {Widget} parent\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.chart = null;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     *\n     * We defend against outside modifications by extending the chart data. It\n     * may be overkill.\n     *\n     * @override\n     * @returns {Object}\n     */\n    __get: function () {\n        return Object.assign({ isSample: this.isSampleModel }, this.chart);\n    },\n    /**\n     * Initial loading.\n     *\n     * @todo All the work to fall back on the graph_groupbys keys in the context\n     * should be done by the graphView I think.\n     *\n     * @param {Object} params\n     * @param {Object} params.context\n     * @param {Object} params.fields\n     * @param {string[]} params.domain\n     * @param {string[]} params.groupBys a list of valid field names\n     * @param {string[]} params.groupedBy a list of valid field names\n     * @param {boolean} params.stacked\n     * @param {string} params.measure a valid field name\n     * @param {'pie'|'bar'|'line'} params.mode\n     * @param {string} params.modelName\n     * @param {Object} params.timeRanges\n     * @returns {Promise} The promise does not return a handle, we don't need\n     *   to keep track of various entities.\n     */\n    __load: function (params) {\n        var groupBys = params.context.graph_groupbys || params.groupBys;\n        this.initialGroupBys = groupBys;\n        this.fields = params.fields;\n        this.modelName = params.modelName;\n        this.chart = Object.assign({\n            context: params.context,\n            dataPoints: [],\n            domain: params.domain,\n            groupBy: params.groupedBy.length ? params.groupedBy : groupBys,\n            measure: params.context.graph_measure || params.measure,\n            mode: params.context.graph_mode || params.mode,\n            origins: [],\n            stacked: params.stacked,\n            timeRanges: params.timeRanges,\n            orderBy: params.orderBy\n        });\n\n        if (this.chart.measure === \"__count\") {\n            this.chart.measure = \"__count__\";\n        }\n\n        this._computeDerivedParams();\n\n        return this._loadGraph();\n    },\n    /**\n     * Reload data.  It is similar to the load function. Note that we ignore the\n     * handle parameter, we always expect our data to be in this.chart object.\n     *\n     * @todo This method takes 'groupBy' and load method takes 'groupedBy'. This\n     *   is insane.\n     *\n     * @param {any} handle ignored!\n     * @param {Object} params\n     * @param {boolean} [params.stacked]\n     * @param {Object} [params.context]\n     * @param {string[]} [params.domain]\n     * @param {string[]} [params.groupBy]\n     * @param {string} [params.measure] a valid field name\n     * @param {string} [params.mode] one of 'bar', 'pie', 'line'\n     * @param {Object} [params.timeRanges]\n     * @returns {Promise}\n     */\n    __reload: function (handle, params) {\n        if ('context' in params) {\n            this.chart.context = params.context;\n            this.chart.groupBy = params.context.graph_groupbys || this.chart.groupBy;\n            this.chart.measure = params.context.graph_measure || this.chart.measure;\n            this.chart.mode = params.context.graph_mode || this.chart.mode;\n        }\n        if ('domain' in params) {\n            this.chart.domain = params.domain;\n        }\n        if ('groupBy' in params) {\n            this.chart.groupBy = params.groupBy.length ? params.groupBy : this.initialGroupBys;\n        }\n        if ('measure' in params) {\n            this.chart.measure = params.measure;\n        }\n        if ('timeRanges' in params) {\n            this.chart.timeRanges = params.timeRanges;\n        }\n\n        if (this.chart.measure === \"__count\") {\n            this.chart.measure = \"__count__\";\n        }\n\n        this._computeDerivedParams();\n\n        if ('mode' in params) {\n            this.chart.mode = params.mode;\n            return Promise.resolve();\n        }\n        if ('stacked' in params) {\n            this.chart.stacked = params.stacked;\n            return Promise.resolve();\n        }\n        if ('orderBy' in params) {\n            this.chart.orderBy = params.orderBy;\n            return Promise.resolve();\n        }\n        return this._loadGraph();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Compute this.chart.processedGroupBy, this.chart.domains, this.chart.origins,\n     * and this.chart.comparisonFieldIndex.\n     * Those parameters are determined by this.chart.timeRanges, this.chart.groupBy, and this.chart.domain.\n     *\n     * @private\n     */\n    _computeDerivedParams: function () {\n        this.chart.processedGroupBy = this._processGroupBy(this.chart.groupBy);\n\n        const { range, rangeDescription, comparisonRange, comparisonRangeDescription, fieldName } = this.chart.timeRanges;\n        if (range) {\n            this.chart.domains = [\n                this.chart.domain.concat(range),\n                this.chart.domain.concat(comparisonRange),\n            ];\n            this.chart.origins = [rangeDescription, comparisonRangeDescription];\n            const groupBys = this.chart.processedGroupBy.map(function (gb) {\n                return gb.split(\":\")[0];\n            });\n            this.chart.comparisonFieldIndex = groupBys.indexOf(fieldName);\n        } else {\n            this.chart.domains = [this.chart.domain];\n            this.chart.origins = [\"\"];\n            this.chart.comparisonFieldIndex = -1;\n        }\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        return this.chart.dataPoints.length === 0;\n    },\n    /**\n     * Fetch and process graph data.  It is basically a(some) read_group(s)\n     * with correct fields for each domain.  We have to do some light processing\n     * to separate date groups in the field list, because they can be defined\n     * with an aggregation function, such as my_date:week.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    _loadGraph: function () {\n        var self = this;\n        this.chart.dataPoints = [];\n        var groupBy = this.chart.processedGroupBy;\n        var fields = _.map(groupBy, function (groupBy) {\n            return groupBy.split(':')[0];\n        });\n        const loadId = this.loadId ? ++this.loadId : 1;\n        this.loadId = loadId;\n\n        if (this.chart.measure !== '__count__') {\n            if (this.fields[this.chart.measure].type === 'many2one') {\n                fields = fields.concat(this.chart.measure + \":count_distinct\");\n            }\n            else {\n                fields = fields.concat(this.chart.measure);\n            }\n        }\n\n        var context = _.extend({fill_temporal: true}, this.chart.context);\n\n        var proms = [];\n        this.chart.domains.forEach(function (domain, originIndex) {\n            proms.push(self._rpc({\n                model: self.modelName,\n                method: 'read_group',\n                context: context,\n                domain: domain,\n                fields: fields,\n                groupBy: groupBy,\n                lazy: false,\n            }).then(self._processData.bind(self, originIndex, loadId)));\n        });\n        return Promise.all(proms);\n    },\n    /**\n     * Since read_group is insane and returns its result on different keys\n     * depending of some input, we have to normalize the result.\n     * Each group coming from the read_group produces a dataPoint\n     *\n     * @private\n     * @param {number} originIndex\n     * @param {any} rawData result from the read_group\n     */\n    _processData: function (originIndex, loadId, rawData) {\n        if (loadId < this.loadId) {\n            return;\n        }\n        var self = this;\n        var isCount = this.chart.measure === '__count__';\n        var labels;\n\n        function getLabels (dataPt) {\n            return self.chart.processedGroupBy.map(function (field) {\n                return self._sanitizeValue(dataPt[field], field.split(\":\")[0]);\n            });\n        }\n        rawData.forEach(function (dataPt){\n            labels = getLabels(dataPt);\n            var count = dataPt.__count || dataPt[self.chart.processedGroupBy[0]+'_count'] || 0;\n            var value = isCount ? count : dataPt[self.chart.measure];\n            if (value instanceof Array) {\n                // when a many2one field is used as a measure AND as a grouped\n                // field, bad things happen.  The server will only return the\n                // grouped value and will not aggregate it.  Since there is a\n                // name clash, we are then in the situation where this value is\n                // an array.  Fortunately, if we group by a field, then we can\n                // say for certain that the group contains exactly one distinct\n                // value for that field.\n                value = 1;\n            }\n            self.chart.dataPoints.push({\n                resId: dataPt[self.chart.groupBy[0]] instanceof Array ? dataPt[self.chart.groupBy[0]][0] : -1,\n                count: count,\n                domain: dataPt.__domain,\n                value: value,\n                labels: labels,\n                originIndex: originIndex,\n            });\n        });\n    },\n    /**\n     * Process the groupBy parameter in order to keep only the finer interval option for\n     * elements based on date/datetime field (e.g. 'date:year'). This means that\n     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.\n     * For instance,\n     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].\n     *\n     * @private\n     * @param {string[]} groupBy\n     * @returns {string[]}\n     */\n    _processGroupBy: function(groupBy) {\n        const groupBysMap = new Map();\n        for (const gb of groupBy) {\n            let [fieldName, interval] = gb.split(':');\n            const field = this.fields[fieldName];\n            if (['date', 'datetime'].includes(field.type)) {\n                interval = interval || DEFAULT_INTERVAL;\n            }\n            if (groupBysMap.has(fieldName)) {\n                const registeredInterval = groupBysMap.get(fieldName);\n                if (rankInterval(registeredInterval) < rankInterval(interval)) {\n                    groupBysMap.set(fieldName, interval);\n                }\n            } else {\n                groupBysMap.set(fieldName, interval);\n            }\n        }\n        return [...groupBysMap].map(([fieldName, interval]) => {\n            if (interval) {\n                return `${fieldName}:${interval}`;\n            }\n            return fieldName;\n        });\n    },\n    /**\n     * Helper function (for _processData), turns various values in a usable\n     * string form, that we can display in the interface.\n     *\n     * @private\n     * @param {any} value value for the field fieldName received by the read_group rpc\n     * @param {string} fieldName\n     * @returns {string}\n     */\n    _sanitizeValue: function (value, fieldName) {\n        if (value === false && this.fields[fieldName].type !== 'boolean') {\n            return _t(\"Undefined\");\n        }\n        if (value instanceof Array) {\n            return value[1];\n        }\n        if (fieldName && (this.fields[fieldName].type === 'selection')) {\n            var selected = _.where(this.fields[fieldName].selection, {0: value})[0];\n            return selected ? selected[1] : value;\n        }\n        return value;\n    },\n});\n\n});\n", "odoo.define(\"web/static/src/js/views/graph/graph_renderer\", function (require) {\n    \"use strict\";\n\n    const AbstractRenderer = require(\"web.AbstractRendererOwl\");\n    const { DateClasses } = require(\"web.dataComparisonUtils\");\n    const fieldUtils = require(\"web.field_utils\");\n    const { sortBy } = require(\"web.utils\");\n\n    const {\n        COLORS,\n        DEFAULT_BG,\n        FORMAT_OPTIONS,\n        MAX_LEGEND_LENGTH,\n        getColor,\n        getMaxWidth,\n        hexToRGBA,\n        shortenLabel,\n    } = require(\"web/static/src/js/views/graph/graph_utils\");\n\n    const { useRef } = owl.hooks;\n    class GraphRenderer extends AbstractRenderer {\n        constructor() {\n            super(...arguments);\n\n            this.noDataLabel = [this.env._t(\"No data\")];\n            this.fakeDataLabel = [\"\"];\n            this.sampleDataTargets = [\".o_graph_canvas_container\"];\n            this._processProps(this.props);\n\n            this.canvasRef = useRef(\"canvas\");\n            this.containerRef = useRef(\"container\");\n        }\n\n        async willUpdateProps(nextProps) {\n            await super.willUpdateProps(...arguments);\n            this._processProps(nextProps);\n        }\n\n        mounted() {\n            super.mounted();\n            this._renderChart();\n        }\n\n        patched() {\n            super.patched();\n            this._renderChart();\n        }\n\n        //---------------------------------------------------------------------\n        // Getters\n        //---------------------------------------------------------------------\n\n        get measureDescription() {\n            const measure = this.props.measures.find(m => m.fieldName === this.props.measure);\n            return measure ? measure.description : this.props.fields[this.props.measure].string;\n        }\n\n        //---------------------------------------------------------------------\n        // Private\n        //---------------------------------------------------------------------\n\n        /**\n         * This function aims to remove a suitable number of lines from the\n         * tooltip in order to make it reasonably visible. A message indicating\n         * the number of lines is added if necessary.\n         * @private\n         * @param {Number} maxTooltipHeight this the max height in pixels of the tooltip\n         */\n        _adjustTooltipHeight(maxTooltipHeight) {\n            const sizeOneLine = this.tooltip.querySelector(\"tbody tr\").clientHeight;\n            const tbodySize = this.tooltip.querySelector(\"tbody\").clientHeight;\n            const toKeep = Math.max(0, Math.floor(\n                (maxTooltipHeight - (this.tooltip.clientHeight - tbodySize)\n                ) / sizeOneLine) - 1);\n            const lines = this.tooltip.querySelectorAll(\"tbody tr\");\n            const toRemove = lines.length - toKeep;\n            if (toRemove > 0) {\n                for (let index = toKeep; index < lines.length; ++index) {\n                    lines[index].remove();\n                }\n                const tr = document.createElement(\"tr\");\n                const td = document.createElement(\"td\");\n                tr.classList.add(\"o_show_more\");\n                td.innerHTML = this.env._t(\"...\");\n                tr.appendChild(td);\n                this.tooltip.querySelector(\"tbody\").appendChild(tr);\n            }\n        }\n\n        /**\n         * Creates a bar chart config.\n         * @private\n         */\n        _createBarChartConfig() {\n            // prepare data\n            const data = this._prepareData(this.processedDataPoints);\n\n            for (let index = 0; index < data.datasets.length; ++index) {\n                const dataset = data.datasets[index];\n                // used when stacked\n                if (this.props.stacked) {\n                    dataset.stack = this.props.origins[dataset.originIndex];\n                }\n                // set dataset color\n                dataset.backgroundColor = getColor(index);\n            }\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create bar chart config\n            return { data, options, type: \"bar\" };\n        }\n\n        /**\n         * Returns the graph configuration object.\n         * @private\n         * @returns {Object}\n         */\n        _createConfig() {\n            if (this.noContentHelperData) {\n                return {};\n            }\n            if (this.props.comparisonFieldIndex === 0) {\n                this.dateClasses = this._getDateClasses(this.processedDataPoints);\n            }\n            switch (this.props.mode) {\n                case \"bar\": return this._createBarChartConfig();\n                case \"line\": return this._createLineChartConfig();\n                case \"pie\": return this._createPieChartConfig();\n            }\n        }\n\n        /**\n         * Creates a line chart config.\n         * @private\n         */\n        _createLineChartConfig() {\n            // prepare data\n            const data = this._prepareData(this.processedDataPoints);\n            for (let index = 0; index < data.datasets.length; ++index) {\n                const dataset = data.datasets[index];\n                if (\n                    this.props.processedGroupBy.length <= 1 &&\n                    this.props.origins.length > 1\n                ) {\n                    if (dataset.originIndex === 0) {\n                        dataset.fill = \"origin\";\n                        dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);\n                        dataset.borderColor = hexToRGBA(COLORS[0], 1);\n                    } else if (dataset.originIndex === 1) {\n                        dataset.borderColor = hexToRGBA(COLORS[1], 1);\n                    } else {\n                        dataset.borderColor = getColor(index);\n                    }\n                } else {\n                    dataset.borderColor = getColor(index);\n                }\n                if (data.labels.length === 1) {\n                    // shift of the real value to right. This is done to\n                    // center the points in the chart. See data.labels below in\n                    // Chart parameters\n                    dataset.data.unshift(undefined);\n                }\n                dataset.pointBackgroundColor = dataset.borderColor;\n                dataset.pointBorderColor = \"rgba(0,0,0,0.2)\";\n            }\n            if (data.datasets.length === 1 && data.datasets[0].originIndex === 0) {\n                const dataset = data.datasets[0];\n                dataset.fill = \"origin\";\n                dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);\n            }\n\n            // center the points in the chart (without that code they are put\n            // on the left and the graph seems empty)\n            data.labels = data.labels.length > 1 ?\n                data.labels :\n                [this.fakeDataLabel, ...data.labels, this.fakeDataLabel];\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create line chart config\n            return { data, options, type: \"line\" };\n        }\n\n        /**\n         * Creates a pie chart config.\n         * @private\n         */\n        _createPieChartConfig() {\n            // prepare data\n            let data = {};\n            const allZero = this.processedDataPoints.every(\n                datapt => datapt.value === 0\n            );\n            if (allZero) {\n                // add fake data to display a pie chart with a grey zone associated\n                // with every origin\n                data.labels = [this.noDataLabel];\n                data.datasets = this.props.origins.map(origin => {\n                    return {\n                        label: origin,\n                        data: [1],\n                        backgroundColor: [DEFAULT_BG],\n                    };\n                });\n            } else {\n                data = this._prepareData(this.processedDataPoints);\n                // give same color to same groups from different origins\n                const colors = data.labels.map((_, index) => getColor(index));\n                for (const dataset of data.datasets) {\n                    dataset.backgroundColor = colors;\n                    dataset.borderColor = \"rgba(255,255,255,0.6)\";\n                }\n                // make sure there is a zone associated with every origin\n                const representedOriginIndexes = data.datasets.map(\n                    dataset => dataset.originIndex\n                );\n                let addNoDataToLegend = false;\n                const fakeData = new Array(data.labels.length).concat([1]);\n\n                for (let index = 0; index < this.props.origins.length; ++index) {\n                    const origin = this.props.origins[index];\n                    if (!representedOriginIndexes.includes(index)) {\n                        data.datasets.splice(index, 0, {\n                            label: origin,\n                            data: fakeData,\n                            backgroundColor: [...colors, DEFAULT_BG],\n                        });\n                        addNoDataToLegend = true;\n                    }\n                }\n                if (addNoDataToLegend) {\n                    data.labels.push(this.noDataLabel);\n                }\n            }\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create pie chart config\n            return { data, options, type: \"pie\" };\n        }\n\n        /**\n         * Creates a custom HTML tooltip.\n         * @private\n         * @param {Object} tooltipModel see chartjs documentation\n         */\n        _customTooltip(tooltipModel) {\n            this.el.style.cursor = \"\";\n            this._removeTooltips();\n            if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {\n                return;\n            }\n            if (this._isRedirectionEnabled()) {\n                this.el.style.cursor = \"pointer\";\n            }\n\n            const chartAreaTop = this.chart.chartArea.top;\n            const rendererTop = this.el.getBoundingClientRect().top;\n\n            const innerHTML = this.env.qweb.renderToString(\"web.GraphRenderer.CustomTooltip\", {\n                maxWidth: getMaxWidth(this.chart.chartArea),\n                measure: this.measureDescription,\n                mode: this.props.mode,\n                tooltipItems: this._getTooltipItems(tooltipModel),\n            });\n            const template = Object.assign(document.createElement(\"template\"), { innerHTML });\n            this.tooltip = template.content.firstChild;\n\n            this.containerRef.el.prepend(this.tooltip);\n\n            let top;\n            const tooltipHeight = this.tooltip.clientHeight;\n            const minTopAllowed = Math.floor(chartAreaTop);\n            const maxTopAllowed = Math.floor(window.innerHeight - (rendererTop + tooltipHeight)) - 2;\n            const y = Math.floor(tooltipModel.y);\n\n            if (minTopAllowed <= maxTopAllowed) {\n                // Here we know that the full tooltip can fit in the screen.\n                // We put it in the position where Chart.js would put it\n                // if two conditions are respected:\n                //  1: the tooltip is not cut (because we know it is possible to not cut it)\n                //  2: the tooltip does not hide the legend.\n                // If it is not possible to use the Chart.js proposition (y)\n                // we use the best approximated value.\n                if (y <= maxTopAllowed) {\n                    if (y >= minTopAllowed) {\n                        top = y;\n                    } else {\n                        top = minTopAllowed;\n                    }\n                } else {\n                    top = maxTopAllowed;\n                }\n            } else {\n                // Here we know that we cannot satisfy condition 1 above,\n                // so we position the tooltip at the minimal position and\n                // cut it the minimum possible.\n                top = minTopAllowed;\n                const maxTooltipHeight = window.innerHeight - (rendererTop + chartAreaTop) - 2;\n                this._adjustTooltipHeight(maxTooltipHeight);\n            }\n\n            this._fixTooltipLeftPosition(this.tooltip, tooltipModel.x);\n            this.tooltip.style.top = Math.floor(top) + \"px\";\n        }\n\n        /**\n         * Filters out some dataPoints because they would lead to bad graphics.\n         * The filtering is done with respect to the graph view mode.\n         * Note that the method does not alter this.state.dataPoints, since we\n         * want to be able to change of mode without fetching data again:\n         * we simply present the same data in a different way.\n         * Note: this should be moved to the model at some point.\n         * @private\n         * @param {Object} props\n         * @returns {Object[]}\n         */\n        _filterDataPoints(props) {\n            let dataPoints = [];\n            if (props.mode === \"line\") {\n                let counts = 0;\n                for (const dataPoint of props.dataPoints) {\n                    if (dataPoint.labels[0] !== this.env._t(\"Undefined\")) {\n                        dataPoints.push(dataPoint);\n                    }\n                    counts += dataPoint.count;\n                }\n                // data points with zero count might have been created on purpose\n                // we only remove them if there are no data point with positive count\n                if (counts === 0) {\n                    dataPoints = [];\n                }\n            } else {\n                dataPoints = props.dataPoints.filter(\n                    dataPoint => dataPoint.count > 0\n                );\n            }\n            return dataPoints;\n        }\n\n        /**\n         * Sets best left position of a tooltip approaching the proposal x.\n         * @private\n         * @param {DOMElement} tooltip\n         * @param {number} x, left offset proposed\n         */\n        _fixTooltipLeftPosition(tooltip, x) {\n            let left;\n            const tooltipWidth = tooltip.clientWidth;\n            const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);\n            const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);\n            x = Math.floor(x);\n            if (x <= maxLeftAllowed) {\n                if (x >= minLeftAllowed) {\n                    left = x;\n                } else {\n                    left = minLeftAllowed;\n                }\n            } else {\n                left = maxLeftAllowed;\n            }\n            tooltip.style.left = left + \"px\";\n        }\n\n        /**\n         * Used to format correctly the values in tooltips and yAxes.\n         * @private\n         * @param {number} value\n         * @returns {string} The value formatted using fieldUtils.format.float\n         */\n        _formatValue(value) {\n            const formatter = fieldUtils.format.float;\n            const measure = this.props.fields[this.props.measure];\n            const formatedValue = formatter(value, measure, FORMAT_OPTIONS);\n            return formatedValue;\n        }\n\n        /**\n         * Determines the initial section of the labels array over which\n         * a dataset has to be completed. The section only depends on the\n         * datasets origins.\n         * @private\n         * @param {number} originIndex\n         * @param {number} defaultLength\n         * @returns {number}\n         */\n        _getDatasetDataLength(originIndex, defaultLength) {\n            if (this.props.mode !== \"pie\" && this.props.comparisonFieldIndex === 0) {\n                return this.dateClasses.dateSets[originIndex].length;\n            }\n            return defaultLength;\n        }\n\n        /**\n         * Determines the dataset to which the data point belongs.\n         * @private\n         * @param {Object} dataPoint\n         * @returns {string}\n         */\n        _getDatasetLabel({ labels, originIndex }) {\n            if (this.props.mode === \"pie\") {\n                return this.props.origins[originIndex];\n            }\n            // ([origin] + second to last groupBys) or measure\n            let datasetLabel = labels.slice(1).join(\"/\");\n            if (this.props.origins.length > 1) {\n                datasetLabel = this.props.origins[originIndex] + (\n                    datasetLabel ? (\"/\" + datasetLabel) : \"\"\n                );\n            }\n            return datasetLabel || this.measureDescription;\n        }\n\n        /**\n         * Returns a DateClasses instance used to manage equivalence of dates.\n         * @private\n         * @param {Object[]} dataPoints\n         * @returns {DateClasses}\n         */\n        _getDateClasses(dataPoints) {\n            const dateSets = this.props.origins.map(() => []);\n            for (const { labels, originIndex } of dataPoints) {\n                dateSets[originIndex].push(labels[this.props.comparisonFieldIndex]);\n            }\n            return new DateClasses(dateSets.map(dateSet => [...new Set(dateSet)]));\n        }\n\n        /**\n         * Returns an object used to style chart elements independently from\n         * the datasets.\n         * @private\n         * @returns {Object}\n         */\n        _getElementOptions() {\n            const elementOptions = {};\n            if (this.props.mode === \"bar\") {\n                elementOptions.rectangle = { borderWidth: 1 };\n            } else if (this.props.mode === \"line\") {\n                elementOptions.line = {\n                    tension: 0,\n                    fill: false,\n                };\n            }\n            return elementOptions;\n        }\n\n        /**\n         * Gets the label over which the data point is.\n         * @private\n         * @param {Object} dataPoint\n         * @returns {Array}\n         */\n        _getLabel({ labels, originIndex }) {\n            const index = this.props.comparisonFieldIndex;\n            if (this.props.mode !== \"pie\") {\n                if (index === 0) {\n                    return [this.dateClasses.dateClass(originIndex, labels[index])];\n                } else {\n                    return labels.slice(0, 1);\n                }\n            } else if (index === 0) {\n                return [\n                    this.dateClasses.dateClass(originIndex, labels[index]),\n                    ...labels.slice(index + 1)\n                ];\n            } else {\n                return labels;\n            }\n        }\n\n        /**\n         * Returns the options used to generate the chart legend.\n         * @private\n         * @param {number} datasetsCount\n         * @returns {Object}\n         */\n        _getLegendOptions(datasetsCount) {\n            const legendOptions = {\n                display: datasetsCount <= MAX_LEGEND_LENGTH,\n                position: \"top\",\n                onHover: this._onlegendHover.bind(this),\n                onLeave: this._onLegendLeave.bind(this),\n            };\n            if (this.props.mode === \"line\") {\n                legendOptions.onClick = this._onLegendClick.bind(this);\n            }\n            if (this.props.mode !== \"pie\") {\n                let referenceColor;\n                if (this.props.mode === \"bar\") {\n                    referenceColor = \"backgroundColor\";\n                } else {\n                    referenceColor = \"borderColor\";\n                }\n                legendOptions.labels = {\n                    generateLabels: chart => {\n                        const { data } = chart;\n                        const labels = data.datasets.map((dataset, index) => {\n                            return {\n                                text: shortenLabel(dataset.label),\n                                fullText: dataset.label,\n                                fillStyle: dataset[referenceColor],\n                                hidden: !chart.isDatasetVisible(index),\n                                lineCap: dataset.borderCapStyle,\n                                lineDash: dataset.borderDash,\n                                lineDashOffset: dataset.borderDashOffset,\n                                lineJoin: dataset.borderJoinStyle,\n                                lineWidth: dataset.borderWidth,\n                                strokeStyle: dataset[referenceColor],\n                                pointStyle: dataset.pointStyle,\n                                datasetIndex: index,\n                            };\n                        });\n                        return labels;\n                    },\n                };\n            } else {\n                const { comparisonFieldIndex } = this.props;\n                legendOptions.labels = {\n                    generateLabels: chart => {\n                        const { data } = chart;\n                        const metaData = data.datasets.map(\n                            (_, index) => chart.getDatasetMeta(index).data\n                        );\n                        const labels = data.labels.map((label, index) => {\n                            const hidden = metaData.some(\n                                data => data[index] && data[index].hidden\n                            );\n                            const fullText = this._relabelling(label, comparisonFieldIndex);\n                            const text = shortenLabel(fullText);\n                            const fillStyle = label === this.noDataLabel ?\n                                DEFAULT_BG :\n                                getColor(index);\n                            return { text, fullText, fillStyle, hidden, index };\n                        });\n                        return labels;\n                    },\n                };\n            }\n            return legendOptions;\n        }\n\n        /**\n         * Determines whether the data are good, and displays an error message\n         * if this is not the case.\n         * @private\n         * @returns {Object | null}\n         */\n        _getNoContentHelper() {\n            if (this.props.mode === \"pie\") {\n                const dataPoints = this.processedDataPoints;\n                const someNegative = dataPoints.some(dataPt => dataPt.value < 0);\n                const somePositive = dataPoints.some(dataPt => dataPt.value > 0);\n                if (someNegative && somePositive) {\n                    return {\n                        title: this.env._t(\"Invalid data\"),\n                        description: [\n                            this.env._t(\"Pie chart cannot mix positive and negative numbers. \"),\n                            this.env._t(\"Try to change your domain to only display positive results\")\n                        ].join(\"\")\n                    };\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Returns the options used to generate the chart axes.\n         * @private\n         * @returns {Object}\n         */\n        _getScaleOptions() {\n            if (this.props.mode === \"pie\") {\n                return {};\n            }\n            const { comparisonFieldIndex } = this.props;\n            const xAxes = [{\n                type: \"category\",\n                scaleLabel: {\n                    display: this.props.processedGroupBy.length && !this.props.isEmbedded,\n                    labelString: this.props.processedGroupBy.length ?\n                        this.props.fields[this.props.processedGroupBy[0].split(\":\")[0]].string :\n                        \"\",\n                },\n                ticks: { callback: label => this._relabelling(label, comparisonFieldIndex) },\n            }];\n            const yAxes = [{\n                type: \"linear\",\n                scaleLabel: {\n                    display: !this.props.isEmbedded,\n                    labelString: this.measureDescription,\n                },\n                ticks: {\n                    callback: value => this._formatValue(value),\n                    suggestedMax: 0,\n                    suggestedMin: 0,\n                },\n            }];\n            return { xAxes, yAxes };\n        }\n\n        /**\n         * Extracts the important information from a tooltipItem generated by\n         * Charts.js (a tooltip item corresponds to a line (different from\n         * measure name) of a tooltip).\n         * @private\n         * @param {Object} item\n         * @param {Object} data\n         * @returns {Object}\n         */\n        _getTooltipItemContent(item, data) {\n            const { comparisonFieldIndex } = this.props;\n            const dataset = data.datasets[item.datasetIndex];\n            const id = item.index;\n            let label = data.labels[item.index];\n            let value;\n            let boxColor;\n            let percentage;\n            if (this.props.mode === \"pie\") {\n                if (label === this.noDataLabel) {\n                    value = this._formatValue(0);\n                } else {\n                    value = this._formatValue(dataset.data[item.index]);\n                    const totalData = dataset.data.reduce((a, b) => a + b, 0);\n                    percentage = totalData && ((dataset.data[item.index] * 100) / totalData).toFixed(2);\n                }\n                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);\n                if (this.props.origins.length > 1) {\n                    label = `${dataset.label}/${label}`;\n                }\n                boxColor = dataset.backgroundColor[item.index];\n            } else {\n                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);\n                if (\n                    this.props.processedGroupBy.length > 1 ||\n                    this.props.origins.length > 1\n                ) {\n                    label = `${label}/${dataset.label}`;\n                }\n                value = this._formatValue(item.yLabel);\n                boxColor = this.props.mode === \"bar\" ?\n                    dataset.backgroundColor :\n                    dataset.borderColor;\n            }\n            return { id, label, value, boxColor, percentage };\n        }\n\n        /**\n         * This function extracts the information from the data points in\n         * tooltipModel.dataPoints (corresponding to datapoints over a given\n         * label determined by the mouse position) that will be displayed in a\n         * custom tooltip.\n         * @private\n         * @param {Object} tooltipModel see chartjs documentation\n         * @return {Object[]}\n         */\n        _getTooltipItems(tooltipModel) {\n            const { data } = this.chart.config;\n            const sortedDataPoints = sortBy(tooltipModel.dataPoints, \"yLabel\", \"desc\");\n            return sortedDataPoints.map(\n                item => this._getTooltipItemContent(item, data)\n            );\n        }\n\n        /**\n         * Returns the options used to generate chart tooltips.\n         * @private\n         * @returns {Object}\n         */\n        _getTooltipOptions() {\n            const tooltipOptions = {\n                // disable Chart.js tooltips\n                enabled: false,\n                custom: this._customTooltip.bind(this),\n            };\n            if (this.props.mode === \"line\") {\n                tooltipOptions.mode = \"index\";\n                tooltipOptions.intersect = false;\n            }\n            return tooltipOptions;\n        }\n\n        /**\n         * Returns true iff the current graph can be clicked on to redirect to\n         * the list of records.\n         * @private\n         * @returns {boolean}\n         */\n        _isRedirectionEnabled() {\n            return !this.props.disableLinking && this.props.mode !== \"line\";\n        }\n\n        /**\n         * Separates dataPoints coming from the read_group(s) into different\n         * datasets. This function returns the parameters data and labels used\n         * to produce the charts.\n         * @param {Object[]} dataPoints\n         * @returns {Object}\n         */\n        _prepareData(dataPoints) {\n            const labelMap = {};\n            const labels = [];\n            for (const dataPt of dataPoints) {\n                const label = this._getLabel(dataPt);\n                const labelKey = `${dataPt.resId}:${JSON.stringify(label)}`;\n                const index = labelMap[labelKey];\n                if (index === undefined) {\n                    labelMap[labelKey] = dataPt.labelIndex = labels.length;\n                    labels.push(label);\n                } else {\n                    dataPt.labelIndex = index;\n                }\n            }\n\n            // dataPoints --> datasets\n            const datasetsTmp = {};\n            for (const dp of dataPoints) {\n                const datasetLabel = this._getDatasetLabel(dp);\n                if (!(datasetLabel in datasetsTmp)) {\n                    const dataLength = this._getDatasetDataLength(dp.originIndex, labels.length);\n                    datasetsTmp[datasetLabel] = {\n                        data: new Array(dataLength).fill(0),\n                        domain: new Array(dataLength).fill([]),\n                        label: datasetLabel,\n                        originIndex: dp.originIndex,\n                    };\n                }\n                const labelIndex = dp.labelIndex;\n                datasetsTmp[datasetLabel].data[labelIndex] = dp.value;\n                datasetsTmp[datasetLabel].domain[labelIndex] = dp.domain;\n            }\n            // sort by origin\n            const datasets = sortBy(Object.values(datasetsTmp), \"originIndex\");\n            return { datasets, labels };\n        }\n\n        /**\n         * Prepares options for the chart according to the current mode\n         * (= chart type). This function returns the parameter options used to\n         * instantiate the chart.\n         * @private\n         * @param {number} datasetsCount\n         * @returns {Object} the chart options used for the current mode\n         */\n        _prepareOptions(datasetsCount) {\n            const options = {\n                maintainAspectRatio: false,\n                scales: this._getScaleOptions(),\n                legend: this._getLegendOptions(datasetsCount),\n                tooltips: this._getTooltipOptions(),\n                elements: this._getElementOptions(),\n            };\n            if (this._isRedirectionEnabled()) {\n                options.onClick = ev => this._onGraphClicked(ev);\n            }\n            return options;\n        }\n\n        /**\n         * Computes various information from the given props object.\n         * @param {Object} props\n         */\n        _processProps(props) {\n            const filteredDataPoints = this._filterDataPoints(props);\n            this.processedDataPoints = this._sortDataPoints(filteredDataPoints, props);\n            this.noContentHelperData = this._getNoContentHelper(props.mode);\n        }\n\n        /**\n         * Determines how to relabel a label according to a given origin. The\n         * idea is that the getLabel function is in general not invertible but\n         * it is when restricted to the set of dataPoints coming from a same\n         * origin.\n         * @private\n         * @param {Array} label\n         * @param {number} index\n         * @param {Array} [originIndex]\n         * @returns {string}\n         */\n        _relabelling(label, index, originIndex) {\n            if (label === this.noDataLabel || label === this.fakeDataLabel) {\n                return label[0];\n            }\n            if (this.props.mode !== \"pie\" && index === 0) {\n                // here label is an array of length 1 and contains a number\n                return this.dateClasses.representative(label, originIndex) || \"\";\n            } else if (this.props.mode === \"pie\" && index === 0) {\n                // here label is an array of length at least one containing string or numbers\n                const labelCopy = label.slice();\n                let newLabel;\n                if (originIndex === undefined) {\n                    newLabel = this.dateClasses.dateClassMembers(label[index]);\n                } else {\n                    newLabel = this.dateClasses.representative(label[index], originIndex);\n                }\n                labelCopy.splice(index, 1, newLabel);\n                return labelCopy.join(\"/\");\n            }\n            // here label is an array containing strings or numbers.\n            return label.join(\"/\") || this.env._t(\"Total\");\n        }\n\n        /**\n         * Removes all existing tooltips.\n         * @private\n         */\n        _removeTooltips() {\n            if (this.tooltip) {\n                this.tooltip.remove();\n                this.tooltip = null;\n            }\n            if (this.legendTooltip) {\n                this.legendTooltip.remove();\n                this.legendTooltip = null;\n            }\n        }\n\n        /**\n         * Instantiates a Chart (Chart.js lib) to render the graph according to\n         * the current config.\n         * @private\n         */\n        _renderChart() {\n            if (this.noContentHelperData) {\n                return;\n            }\n            if (this.chart) {\n                this.chart.destroy();\n            }\n            const config = this._createConfig();\n            const canvasContext = this.canvasRef.el.getContext(\"2d\");\n            this.chart = new Chart(canvasContext, config);\n            // To perform its animations, ChartJS will perform each animation\n            // step in the next animation frame. The initial rendering itself\n            // is delayed for consistency. We can avoid this by manually\n            // advancing the animation service.\n            Chart.animationService.advance();\n        }\n\n        /**\n         * Sorts datapoints according to the current order (ASC or DESC).\n         * Note: this should be moved to the model at some point.\n         * @private\n         * @param {Object[]} dataPoints\n         * @param {Object} props\n         * @returns {Object[]} sorted dataPoints if orderby set on state\n         */\n        _sortDataPoints(dataPoints, props) {\n            if (\n                props.domains.length === 1 &&\n                props.orderBy &&\n                props.mode !== \"pie\" &&\n                props.processedGroupBy.length\n            ) {\n                // group data by their x-axis value, and then sort datapoints\n                // based on the sum of values by group in ascending/descending order\n                const [groupByFieldName] = props.processedGroupBy[0].split(\":\");\n                const { type } = props.fields[groupByFieldName];\n                const groupedDataPoints = {};\n                for (const dataPt of dataPoints) {\n                    const key = type === \"many2one\" ? dataPt.resId : dataPt.labels[0];\n                    if (!groupedDataPoints[key]) {\n                        groupedDataPoints[key] = [];\n                    }\n                    groupedDataPoints[key].push(dataPt);\n                }\n                const groupTotal = group => group.reduce((sum, { value }) => sum + value, 0);\n                dataPoints = sortBy(\n                    Object.values(groupedDataPoints),\n                    groupTotal,\n                    props.orderBy\n                ).flat();\n            }\n            return dataPoints;\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onGraphClicked(ev) {\n            const [activeElement] = this.chart.getElementAtEvent(ev);\n            if (!activeElement) {\n                return;\n            }\n            const { _datasetIndex, _index } = activeElement;\n            const { domain } = this.chart.data.datasets[_datasetIndex];\n            if (domain) {\n                this.trigger(\"open_view\", { domain: domain[_index] });\n            }\n        }\n\n        /**\n         * Overrides the default legend 'onClick' behaviour. This is done to\n         * remove all existing tooltips right before updating the chart.\n         * @private\n         * @param {MouseEvent} ev\n         * @param {Object} legendItem\n         */\n        _onLegendClick(ev, legendItem) {\n            this._removeTooltips();\n            // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138\n            const index = legendItem.datasetIndex;\n            const meta = this.chart.getDatasetMeta(index);\n            meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;\n            this.chart.update();\n        }\n\n        /**\n         * If the text of a legend item has been shortened and the user mouse\n         * hovers that item (actually the event type is mousemove), a tooltip\n         * with the item full text is displayed.\n         * @private\n         * @param {MouseEvent} ev\n         * @param {Object} legendItem\n         */\n        _onlegendHover(ev, legendItem) {\n            this.canvasRef.el.style.cursor = \"pointer\";\n            /**\n             * The string legendItem.text is an initial segment of legendItem.fullText.\n             * If the two coincide, no need to generate a tooltip. If a tooltip\n             * for the legend already exists, it is already good and doesn't\n             * need to be recreated.\n             */\n            if (legendItem.text === legendItem.fullText || this.legendTooltip) {\n                return;\n            }\n\n            const rendererTop = this.el.getBoundingClientRect().top;\n\n            this.legendTooltip = Object.assign(document.createElement(\"div\"), {\n                className: \"o_tooltip_legend\",\n                innerText: legendItem.fullText,\n            });\n            this.legendTooltip.style.top = (ev.clientY - rendererTop) + \"px\";\n            this.legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);\n\n            this.containerRef.el.appendChild(this.legendTooltip);\n\n            this._fixTooltipLeftPosition(this.legendTooltip, ev.clientX);\n        }\n\n        /**\n         * If there's a legend tooltip and the user mouse out of the\n         * corresponding legend item, the tooltip is removed.\n         * @private\n         */\n        _onLegendLeave() {\n            this.canvasRef.el.style.cursor = \"\";\n            if (this.legendTooltip) {\n                this.legendTooltip.remove();\n                this.legendTooltip = null;\n            }\n        }\n    }\n\n    GraphRenderer.template = \"web.Legacy.GraphRenderer\";\n    GraphRenderer.props = {\n        arch: {\n            type: Object,\n            shape: {\n                children: { type: Array, element: Object },\n                attrs: Object,\n                tag: { validate: t => t === \"graph\" },\n            },\n        },\n        comparisonFieldIndex: Number,\n        context: Object,\n        dataPoints: { type: Array, element: Object },\n        disableLinking: Boolean,\n        domain: [Array, String],\n        domains: { type: Array, element: [Array, String] },\n        fields: Object,\n        groupBy: { type: Array, element: String },\n        isEmbedded: Boolean,\n        isSample: { type: Boolean, optional: 1 },\n        measure: String,\n        measures: { type: Array, element: Object },\n        mode: { validate: m => [\"bar\", \"line\", \"pie\"].includes(m) },\n        origins: { type: Array, element: String },\n        processedGroupBy: { type: Array, element: String },\n        stacked: Boolean,\n        timeRanges: Object,\n        noContentHelp: { type: String, optional: 1 },\n        orderBy: { type: [String, Boolean], optional: 1 },\n        title: { type: String, optional: 1 },\n        withSearchPanel: { type: Boolean, optional: 1 },\n    };\n\n    return GraphRenderer;\n\n});\n", "odoo.define('web/static/src/js/views/graph/graph_utils', function (require) {\n\"use strict\";\n\nconst { device } = require(\"web.config\");\n\nconst COLORS = [\n    \"#1f77b4\", \"#ff7f0e\", \"#aec7e8\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\",\n    \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\",\n    \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\",\n];\nconst DEFAULT_BG = \"#d3d3d3\";\n// used to format values in tooltips and yAxes.\nconst FORMAT_OPTIONS = {\n    // allow to decide if utils.human_number should be used\n    humanReadable: value => Math.abs(value) >= 1000,\n    // with the choices below, 1236 is represented by 1.24k\n    minDigits: 1,\n    decimals: 2,\n    // avoid comma separators for thousands in numbers when human_number is used\n    formatterCallback: str => str,\n};\n// hide top legend when too many items for device size\nconst MAX_LEGEND_LENGTH = 4 * Math.max(1, device.size_class);\nconst RGB_REGEX = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\n/**\n * @param {number} index\n * @returns {string}\n */\nfunction getColor(index) {\n    return COLORS[index % COLORS.length];\n}\n\n/**\n * @param {Object} chartArea\n * @returns {string}\n */\nfunction getMaxWidth({ left, right }) {\n    return Math.floor((right - left) / 1.618) + \"px\";\n}\n\n/**\n * @param {string} hex\n * @param {number} opacity\n * @returns {string}\n */\nfunction hexToRGBA(hex, opacity) {\n    const rgb = RGB_REGEX\n        .exec(hex)\n        .slice(1, 4)\n        .map(n => parseInt(n, 16))\n        .join(\",\");\n    return `rgba(${rgb},${opacity})`;\n}\n\n/**\n * Used to avoid too long legend items.\n * @param {string} label\n * @returns {string} shortened version of the input label\n */\nfunction shortenLabel(label) {\n    // string returned could be wrong if a groupby value contain a \"/\"!\n    const groups = label.split(\"/\");\n    let shortLabel = groups.slice(0, 3).join(\"/\");\n    if (shortLabel.length > 30) {\n        shortLabel = `${shortLabel.slice(0, 30)}...`;\n    } else if (groups.length > 3) {\n        shortLabel = `${shortLabel}/...`;\n    }\n    return shortLabel;\n}\n\nreturn {\n    COLORS,\n    DEFAULT_BG,\n    FORMAT_OPTIONS,\n    MAX_LEGEND_LENGTH,\n    RGB_REGEX,\n    getColor,\n    getMaxWidth,\n    hexToRGBA,\n    shortenLabel,\n};\n\n});\n\n", "odoo.define('web.GraphView', function (require) {\n\"use strict\";\n\n/**\n * The Graph View is responsible to display a graphical (meaning: chart)\n * representation of the current dataset.  As of now, it is currently able to\n * display data in three types of chart: bar chart, line chart and pie chart.\n */\n\nvar AbstractView = require('web.AbstractView');\nvar core = require('web.core');\nvar GraphModel = require('web.GraphModel');\nvar Controller = require('web.GraphController');\nconst GraphRenderer = require(\"web/static/src/js/views/graph/graph_renderer\");\nconst RendererWrapper = require(\"web.RendererWrapper\");\nconst viewRegistry = require(\"web.view_registry\");\n\nvar _t = core._t;\nvar _lt = core._lt;\n\nvar searchUtils = require('web.searchUtils');\nvar GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;\n\nvar GraphView = AbstractView.extend({\n    display_name: _lt('Graph'),\n    icon: 'fa-bar-chart',\n    jsLibs: [\n        '/web/static/lib/Chart/Chart.js',\n    ],\n    config: _.extend({}, AbstractView.prototype.config, {\n        Model: GraphModel,\n        Controller: Controller,\n        Renderer: GraphRenderer,\n    }),\n    viewType: 'graph',\n    searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],\n\n    /**\n     * @override\n     */\n    init: function (viewInfo, params) {\n        this._super.apply(this, arguments);\n\n        const additionalMeasures = params.additionalMeasures || [];\n        let measure;\n        const measures = {};\n        const measureStrings = {};\n        let groupBys = [];\n        const groupableFields = {};\n        this.fields.__count__ = { string: _t(\"Count\"), type: 'integer' };\n\n        this.arch.children.forEach(field => {\n            let fieldName = field.attrs.name;\n            if (fieldName === \"id\") {\n                return;\n            }\n            const interval = field.attrs.interval;\n            if (interval) {\n                fieldName = fieldName + ':' + interval;\n            }\n            if (field.attrs.type === 'measure') {\n                const { string } = this.fields[fieldName];\n                measure = fieldName;\n                measures[fieldName] = {\n                    description: string,\n                    fieldName,\n                    groupNumber: 0,\n                    isActive: false,\n                    itemType: 'measure',\n                };\n            } else {\n                groupBys.push(fieldName);\n            }\n            if (field.attrs.string) {\n                measureStrings[fieldName] = field.attrs.string;\n            }\n        });\n\n        for (const name in this.fields) {\n            const field = this.fields[name];\n            if (name !== 'id' && field.store === true) {\n                if (\n                    ['integer', 'float', 'monetary'].includes(field.type) ||\n                    additionalMeasures.includes(name)\n                ) {\n                    measures[name] = {\n                        description: field.string,\n                        fieldName: name,\n                        groupNumber: 0,\n                        isActive: false,\n                        itemType: 'measure',\n                    };\n                }\n                if (GROUPABLE_TYPES.includes(field.type)) {\n                    groupableFields[name] = field;\n                }\n            }\n        }\n        for (const name in measureStrings) {\n            if (measures[name]) {\n                measures[name].description = measureStrings[name];\n            }\n        }\n\n        // Remove invisible fields from the measures\n        this.arch.children.forEach(field => {\n            let fieldName = field.attrs.name;\n            if (field.attrs.invisible && py.eval(field.attrs.invisible)) {\n                groupBys = groupBys.filter(groupBy => groupBy !== fieldName);\n                if (fieldName in groupableFields) {\n                    delete groupableFields[fieldName];\n                }\n                if (!additionalMeasures.includes(fieldName)) {\n                    delete measures[fieldName];\n                }\n            }\n        });\n\n        const sortedMeasures = Object.values(measures).sort((a, b) => {\n                const descA = a.description.toLowerCase();\n                const descB = b.description.toLowerCase();\n                return descA > descB ? 1 : descA < descB ? -1 : 0;\n            });\n        const countMeasure = {\n            description: _t(\"Count\"),\n            fieldName: '__count__',\n            groupNumber: 1,\n            isActive: false,\n            itemType: 'measure',\n        };\n        this.controllerParams.withButtons = params.withButtons !== false;\n        this.controllerParams.measures = [...sortedMeasures, countMeasure];\n        this.controllerParams.groupableFields = groupableFields;\n        this.controllerParams.title = params.title || this.arch.attrs.string || _t(\"Untitled\");\n        // retrieve form and list view ids from the action to open those views\n        // when the graph is clicked\n        function _findView(views, viewType) {\n            const view = views.find(view => {\n                return view.type === viewType;\n            });\n            return [view ? view.viewID : false, viewType];\n        }\n        this.controllerParams.views = [\n            _findView(params.actionViews, 'list'),\n            _findView(params.actionViews, 'form'),\n        ];\n\n        this.rendererParams.fields = this.fields;\n        this.rendererParams.measures = this.controllerParams.measures;\n        this.rendererParams.title = this.arch.attrs.title; // TODO: use attrs.string instead\n        this.rendererParams.disableLinking = !!JSON.parse(this.arch.attrs.disable_linking || '0');\n\n        this.loadParams.mode = this.arch.attrs.type || 'bar';\n        this.loadParams.orderBy = this.arch.attrs.order;\n        this.loadParams.measure = measure || '__count__';\n        this.loadParams.groupBys = groupBys;\n        this.loadParams.fields = this.fields;\n        this.loadParams.comparisonDomain = params.comparisonDomain;\n        this.loadParams.stacked = this.arch.attrs.stacked !== \"False\";\n    },\n\n     /**\n     *\n     * @override\n     */\n    getRenderer(parent, props) {\n        props = Object.assign(props || {}, this.rendererParams);\n        return new RendererWrapper(null, this.config.Renderer, props);\n    },\n});\n\nviewRegistry.add(\"graph\", GraphView);\nreturn GraphView;\n\n});\n", "/** @odoo-module alias=web.PivotController **/\n\n    /**\n     * Odoo Pivot Table Controller\n     *\n     * This class is the Controller for the pivot table view.  It has to coordinate\n     * the actions coming from the search view (through the update method), from\n     * the renderer, from the model, and from the control panel.\n     *\n     * It can display action buttons in the control panel, to select a different\n     * measure, or to perform some other actions such as download/expand/flip the\n     * view.\n     */\n\n    import AbstractController from '../abstract_controller';\n    import core from 'web.core';\n    import framework from 'web.framework';\n    import session from 'web.session';\n\n    const _t = core._t;\n    const QWeb = core.qweb;\n\n    const PivotController = AbstractController.extend({\n        custom_events: Object.assign({}, AbstractController.prototype.custom_events, {\n            closed_header_click: '_onClosedHeaderClicked',\n            open_view: '_onOpenView',\n            opened_header_click: '_onOpenedHeaderClicked',\n            sort_rows: '_onSortRows',\n            groupby_menu_selection: '_onGroupByMenuSelection',\n        }),\n\n        /**\n         * @override\n         * @param parent\n         * @param model\n         * @param renderer\n         * @param {Object} params\n         */\n        init: function (parent, model, renderer, params) {\n            this._super(...arguments);\n\n            this.disableLinking = params.disableLinking;\n            this.measures = params.measures;\n            this.title = params.title;\n            // views to use in the action triggered when a data cell is clicked\n            this.views = params.views;\n            this.groupSelected = null;\n        },\n        /**\n         * @override\n         */\n        destroy: function () {\n            if (this.$buttons) {\n                // remove jquery's tooltip() handlers\n                this.$buttons.find('button').off();\n            }\n            return this._super(...arguments);\n        },\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        /**\n         * Returns the current measures and groupbys, so we can restore the view\n         * when we save the current state in the search view, or when we add it to\n         * the dashboard.\n         *\n         * @override method from AbstractController\n         * @returns {Object}\n         */\n        getOwnedQueryParams: function () {\n            const state = this.model.get({ raw: true });\n            return {\n                context: {\n                    pivot_measures: state.measures,\n                    pivot_column_groupby: state.colGroupBys,\n                    pivot_row_groupby: state.rowGroupBys,\n                }\n            };\n        },\n        /**\n         * Render the buttons according to the PivotView.buttons template and\n         * add listeners on it.\n         * Set this.$buttons with the produced jQuery element\n         *\n         * @override\n         * @param {jQuery} [$node] a jQuery node where the rendered buttons should\n         *   be inserted. $node may be undefined, in which case the PivotView\n         *   does nothing\n         */\n        renderButtons: function ($node) {\n            const context = this._getRenderButtonContext();\n            this.$buttons = $(QWeb.render('PivotView.buttons', context));\n            this.$buttons.click(this._onButtonClick.bind(this));\n            this.$buttons.find('button').tooltip();\n            if ($node) {\n                this.$buttons.appendTo($node);\n            }\n        },\n        /**\n         * @override\n         */\n        updateButtons: function () {\n            if (!this.$buttons) {\n                return;\n            }\n            const state = this.model.get({ raw: true });\n            Object.entries(this.measures).forEach(elt => {\n                const name = elt[0];\n                const isSelected = state.measures.includes(name);\n                this.$buttons.find('.dropdown-item[data-field=\"' + name + '\"]')\n                    .toggleClass('selected', isSelected);\n\n            });\n            const noDataDisplayed = !state.hasData || !state.measures.length;\n            this.$buttons.find('.o_pivot_flip_button').prop('disabled', noDataDisplayed);\n            this.$buttons.find('.o_pivot_expand_button').prop('disabled', noDataDisplayed);\n            this.$buttons.find('.o_pivot_download').prop('disabled', noDataDisplayed);\n        },\n\n        //--------------------------------------------------------------------------\n        // Private\n        //--------------------------------------------------------------------------\n\n        /**\n         * Export the current pivot table data in a xls file. For this, we have to\n         * serialize the current state, then call the server /web/pivot/export_xlsx.\n         * Force a reload before exporting to ensure to export up-to-date data.\n         *\n         * @private\n         */\n        _downloadTable: function () {\n            if (this.model.getTableWidth() > 16384) {\n                this.call('crash_manager', 'show_message', _t(\"For Excel compatibility, data cannot be exported if there are more than 16384 columns.\\n\\nTip: try to flip axis, filter further or reduce the number of measures.\"));\n                framework.unblockUI();\n                return;\n            }\n            const table = this.model.exportData();\n            table.title = this.title;\n            table.model = this.modelName;\n            session.get_file({\n                url: '/web/pivot/export_xlsx',\n                data: { data: JSON.stringify(table) },\n                complete: framework.unblockUI,\n                error: (error) => this.call('crash_manager', 'rpc_error', error),\n            });\n        },\n\n        //--------------------------------------------------------------------------\n        // Handlers\n        //--------------------------------------------------------------------------\n\n        /**\n         * This handler is called when the user clicked on a button in the control\n         * panel.  We then have to react properly: it can either be a change in the\n         * current measures, or a request to flip/expand/download data.\n         *\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onButtonClick: async function (ev) {\n            const $target = $(ev.target);\n            if ($target.hasClass('o_pivot_flip_button')) {\n                this.model.flip();\n                this.update({}, { reload: false });\n            }\n            if ($target.hasClass('o_pivot_expand_button')) {\n                await this.model.expandAll();\n                this.update({}, { reload: false });\n            }\n            if (ev.target.closest('.o_pivot_measures_list')) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                const field = ev.target.dataset.field;\n                if (field) {\n                    this.update({ measure: field });\n                }\n            }\n            if ($target.hasClass('o_pivot_download')) {\n                this._downloadTable();\n            }\n\n            await this._addIncludedButtons(ev);\n        },\n\n        /**\n         * Declared to be overwritten in includes of pivot controller\n         *\n         * @param {MouseEvent} ev\n         * @returns {Promise<void>}\n         * @private\n         */\n        _addIncludedButtons: async function(ev) {},\n        /**\n         * Get the context of rendering of the buttons\n         *\n         * @returns {Object}\n         * @private\n         */\n        _getRenderButtonContext: function () {\n            return {\n                measures: Object.entries(this.measures)\n                .filter(x => x[0] !== '__count')\n                .sort((a, b) => a[1].string.toLowerCase() > b[1].string.toLowerCase() ? 1 : -1),\n            };\n        },\n        /**\n         *\n         * @private\n         * @param {OdooEvent} ev\n         */\n        _onCloseGroup: function (ev) {\n            this.model.closeGroup(ev.data.groupId, ev.data.type);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @param {CustomEvent} ev\n         * @private\n         * */\n        _onOpenedHeaderClicked: function (ev) {\n            this.model.closeGroup(ev.data.cell.groupId, ev.data.type);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @param {CustomEvent} ev\n         * @private\n         * */\n        _onClosedHeaderClicked: async function (ev) {\n            const cell = ev.data.cell;\n            const groupId = cell.groupId;\n            const type = ev.data.type;\n\n            const group = {\n                rowValues: groupId[0],\n                colValues: groupId[1],\n                type: type\n            };\n\n            const state = this.model.get({ raw: true });\n            const groupValues = type === 'row' ? groupId[0] : groupId[1];\n            const groupBys = type === 'row' ?\n                state.rowGroupBys :\n                state.colGroupBys;\n            this.selectedGroup = group;\n            if (groupValues.length < groupBys.length) {\n                const groupBy = groupBys[groupValues.length];\n                await this.model.expandGroup(this.selectedGroup, groupBy);\n                this.update({}, { reload: false });\n            }\n        },\n        /**\n         * This handler is called when the user selects a groupby in the dropdown menu.\n         *\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onGroupByMenuSelection: async function (ev) {\n            ev.stopPropagation();\n\n            const { fieldName, interval } = ev.data;\n            let groupBy = fieldName;\n            if (interval) {\n                groupBy = `${groupBy}:${interval}`;\n            }\n            this.model.addGroupBy(groupBy, this.selectedGroup.type);\n            await this.model.expandGroup(this.selectedGroup, groupBy);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onOpenView: function (ev) {\n            ev.stopPropagation();\n            const cell = ev.data;\n            if (cell.value === undefined || this.disableLinking) {\n                return;\n            }\n\n            const context = Object.assign({}, this.model.data.context);\n            Object.keys(context).forEach(x => {\n                if (x === 'group_by' || x.startsWith('search_default_')) {\n                    delete context[x];\n                }\n            });\n\n            const group = {\n                rowValues: cell.groupId[0],\n                colValues: cell.groupId[1],\n                originIndex: cell.originIndexes[0]\n            };\n\n            const domain = this.model._getGroupDomain(group);\n\n            this.do_action({\n                type: 'ir.actions.act_window',\n                name: this.title,\n                res_model: this.modelName,\n                views: this.views,\n                view_mode: 'list',\n                target: 'current',\n                context: context,\n                domain: domain,\n            });\n        },\n        /**\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onSortRows: function (ev) {\n            this.model.sortRows({\n                groupId: ev.data.groupId,\n                measure: ev.data.measure,\n                order: (ev.data.order || 'desc') === 'asc' ? 'desc' : 'asc',\n                originIndexes: ev.data.originIndexes,\n            });\n            this.update({}, { reload: false });\n        },\n    });\n\n    export default PivotController;\n", "/** @odoo-module alias=web.PivotModel **/\n\n/**\n * Pivot Model\n *\n * The pivot model keeps an in-memory representation of the pivot table that is\n * displayed on the screen.  The exact layout of this representation is not so\n * simple, because a pivot table is at its core a 2-dimensional object, but\n * with a 'tree' component: some rows/cols can be expanded so we zoom into the\n * structure.\n *\n * However, we need to be able to manipulate the data in a somewhat efficient\n * way, and to transform it into a list of lines to be displayed by the renderer.\n *\n * Basicaly the pivot table presents aggregated values for various groups of records\n * in one domain. If a comparison is asked for, two domains are considered.\n *\n * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):\n * ___________________________________________________________________________________________________________________________________________\n * |                    |   Total                                                                                                             |\n * |                    |_____________________________________________________________________________________________________________________|\n * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   Sales total                         |  Sales total                         |  Sales total                         |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |\n * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |\n * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |\n * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |\n * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n *\n *\n * META DATA:\n *\n * In the above pivot table, the records have been grouped using the fields\n *\n *      continent_id, city_id\n *\n * for rows and\n *\n *      sale_team_id\n *\n * for columns.\n *\n * The measure is the field 'sales_total'.\n *\n * Two domains are considered: 'May 2020' and 'June 2020'.\n *\n * In the model,\n *\n *      - rowGroupBys is the list [continent_id, city_id]\n *      - colGroupBys is the list [sale_team_id]\n *      - measures is the list [sales_total]\n *      - domains is the list [d1, d2] with d1 and d2 domain expressions\n *          for say sale_date in May 2020 and June 2020, for instance\n *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]\n *      - origins is the list ['May 2020', 'June 2020']\n *\n * DATA:\n *\n * Recall that a group is constituted by records (in a given domain)\n * that have the same (raw) values for a list of fields.\n * Thus the group itself is identified by this list and the domain.\n * In comparison mode, the same group (forgetting the domain part or 'originIndex')\n * can be eventually found in the two domains.\n * This defines the way in which the groups are identified or not.\n *\n * In the above table, (forgetting the domain) the following groups are found:\n *\n *      the 'row groups'\n *      - Total\n *      - Europe\n *      - America\n *      - Europe, Brussels\n *      - Europe, Paris\n *      - America, Washington\n *\n *      the 'col groups'\n *\n *      - Total\n *      - Sale Team 1\n *      - Sale Team 2\n *\n *      and all non trivial combinations of row groups and col groups\n *\n *      - Europe, Sale Team 1\n *      - Europe, Brussels, Sale Team 2\n *      - America, Washington, Sale Team 1\n *      - ...\n *\n * The list of fields is created from the concatenation of two lists of fields, the first in\n *\n * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys\n * (called rowGroupBys) used to create row groups\n *\n * In the example: [], [continent_id], [continent_id, city_id].\n *\n * and the second in\n * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys\n * (called colGroupBys) used to create col groups.\n *\n * In the example: [], [sale_team_id].\n *\n * Thus there are (n+1)*(m+1) lists of fields possible.\n *\n * In the example: 6 lists possible, namely [],\n *                                          [continent_id], [sale_team_id],\n *                                          [continent_id, sale_team_id], [continent_id, city_id],\n *                                          [continent_id, city_id, sale_team_id]\n *\n * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]\n *\n * For each list of fields possible and each domain considered, one read_group is done\n * and gives results of the form (an exception for list [])\n *\n * g = {\n *  f1: v1, ..., fi: vi,\n *  g1: w1, ..., gj: wj,\n *  m1: x1, ..., mk: xk,\n *  __count: c,\n *  __domain: d\n * }\n *\n * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and\n * m1,...,mk are the fields selected as measures.\n *\n * For example, g = {\n *      continent_id: [1, 'Europe']\n *      sale_team_id: [1, 'Sale Team 1']\n *      sales_count: 25,\n *      __count: 4\n *      __domain: [\n *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],\n *                  ['continent_id', '=', 1],\n *                  ['sale_team_id', '=', 1]\n *                ]\n * }\n *\n * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain\n * or the corresponding 'originIndex'.\n *\n * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]\n * (not forgetting the list [v1,...vi] comes from left).\n * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].\n *\n * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]\n * and [[], [w1,...,wj]].\n *\n * Here is a description of the data structure manipulated by the pivot model.\n *\n * Five objects contain all the data from the read_groups\n *\n *      - rowGroupTree: contains information on row headers\n *             the nodes correspond to the groups of the form [[v1,...,vi], []]\n *             The root is [[], []].\n *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],\n *             this means that a direct child is obtained by grouping records using the single field fi+1\n *\n *             The structure at each level is of the form\n *\n *             {\n *                  root: {\n *                      values: [v1,...,vl],\n *                      labels: [la1,...,lal]\n *                  },\n *                  directSubTrees: {\n *                      v => {\n *                              root: {\n *                                  values: [v1,...,vl,v]\n *                                  labels: [label1,...,labell,label]\n *                              },\n *                              directSubTrees: {...}\n *                          },\n *                      v' => {...},\n *                      ...\n *                  }\n *             }\n *\n *             (directSubTrees is a Map instance)\n *\n *             In the example, the rowGroupTree is:\n *\n *             {\n *                  root: {\n *                      values: [],\n *                      labels: []\n *                  },\n *                  directSubTrees: {\n *                      1 => {\n *                              root: {\n *                                  values: [1],\n *                                  labels: ['Europe'],\n *                              },\n *                              directSubTrees: {\n *                                  1 => {\n *                                          root: {\n *                                              values: [1, 1],\n *                                              labels: ['Europe', 'Brussels'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                                  2 => {\n *                                          root: {\n *                                              values: [1, 2],\n *                                              labels: ['Europe', 'Paris'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                          },\n *                      2 => {\n *                              root: {\n *                                  values: [2],\n *                                  labels: ['America'],\n *                              },\n *                              directSubTrees: {\n *                                  3 => {\n *                                          root: {\n *                                              values: [2, 3],\n *                                              labels: ['America', 'Washington'],\n *                                          }\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                      },\n *                  },\n *             }\n *\n *      - colGroupTree: contains information on col headers\n *              The same as above with right instead of left\n *\n *      - measurements: contains information on measure values for all the groups\n *\n *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])\n *              and values are arrays of length equal to number of origins containing objects of the form\n *                  {m1: x1,...,mk: xk}\n *              The structure looks like\n *\n *              {\n *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]\n *                  ....\n *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],\n *                  ....\n *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],\n *              }\n *              Thus the structure contains all information for all groups and all origins on measure values.\n *\n *\n *              this.measurments[\"[[], []]\"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the\n *              first domain (origin).\n *\n *              In the example:\n *                  {\n *                      \"[[], []]\": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)\n *                      ...\n *                      \"[[1, 2], [2]]\": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)\n *                      ...\n *                  }\n *\n *      - counts: contains information on the number of records in each groups\n *              The structure is similar to the above but the arrays contains numbers (counts)\n *      - groupDomains:\n *              The structure is similar to the above but the arrays contains domains\n *\n *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.\n *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the _getTable function.\n */\n\nimport AbstractModel from '../abstract_model';\nimport concurrency from 'web.concurrency';\nimport core from 'web.core';\nimport dataComparisonUtils from 'web.dataComparisonUtils';\nimport Domain from 'web.Domain';\nimport * as mathUtils from '@web/core/utils/arrays';\nimport session from 'web.session';\n\n\nvar _t = core._t;\nvar cartesian = mathUtils.cartesian;\nvar computeVariation = dataComparisonUtils.computeVariation;\nvar sections = mathUtils.sections;\n\nvar PivotModel = AbstractModel.extend({\n    /**\n     * @override\n     * @param {Object} params\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.numbering = {};\n        this.data = null;\n        this._loadDataDropPrevious = new concurrency.DropPrevious();\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.\n     *\n     * @param {string} groupBy\n     * @param {'row'|'col'} type\n     */\n    addGroupBy: function (groupBy, type) {\n        if (type === 'row') {\n            this.data.expandedRowGroupBys.push(groupBy);\n        } else {\n            this.data.expandedColGroupBys.push(groupBy);\n        }\n    },\n    /**\n     * Close the group with id given by groupId. A type must be specified\n     * in case groupId is [[], []] (the id of the group 'Total') because this\n     * group is present in both colGroupTree and rowGroupTree.\n     *\n     * @param {Array[]} groupId\n     * @param {'row'|'col'} type\n     */\n    closeGroup: function (groupId, type) {\n        var groupBys;\n        var expandedGroupBys;\n        let keyPart;\n        var group;\n        var tree;\n        if (type === 'row') {\n            groupBys = this.data.rowGroupBys;\n            expandedGroupBys = this.data.expandedRowGroupBys;\n            tree = this.rowGroupTree;\n            group = this._findGroup(this.rowGroupTree, groupId[0]);\n            keyPart = 0;\n        } else {\n            groupBys = this.data.colGroupBys;\n            expandedGroupBys = this.data.expandedColGroupBys;\n            tree = this.colGroupTree;\n            group = this._findGroup(this.colGroupTree, groupId[1]);\n            keyPart = 1;\n        }\n\n        const groupIdPart = groupId[keyPart];\n        const range = groupIdPart.map((_, index) => index);\n        function keep(key) {\n            const idPart = JSON.parse(key)[keyPart];\n            return range.some(index => groupIdPart[index] !== idPart[index]) ||\n                    idPart.length ===  groupIdPart.length;\n        }\n        function omitKeys(object) {\n            const newObject = {};\n            for (const key in object) {\n                if (keep(key)) {\n                    newObject[key] = object[key];\n                }\n            }\n            return newObject;\n        }\n        this.measurements = omitKeys(this.measurements);\n        this.counts = omitKeys(this.counts);\n        this.groupDomains = omitKeys(this.groupDomains);\n\n        group.directSubTrees.clear();\n        delete group.sortedKeys;\n        var newGroupBysLength = this._getTreeHeight(tree) - 1;\n        if (newGroupBysLength <= groupBys.length) {\n            expandedGroupBys.splice(0);\n            groupBys.splice(newGroupBysLength);\n        } else {\n            expandedGroupBys.splice(newGroupBysLength - groupBys.length);\n        }\n    },\n    /**\n     * Reload the view with the current rowGroupBys and colGroupBys\n     * This is the easiest way to expand all the groups that are not expanded\n     *\n     * @returns {Promise}\n     */\n    expandAll: function () {\n        return this._loadData();\n    },\n    /**\n     * Expand a group by using groupBy to split it.\n     *\n     * @param {Object} group\n     * @param {string} groupBy\n     * @returns {Promise}\n     */\n    expandGroup: async function (group, groupBy) {\n        var leftDivisors;\n        var rightDivisors;\n\n        if (group.type === 'row') {\n            leftDivisors = [[groupBy]];\n            rightDivisors = sections(this._getGroupBys().colGroupBys);\n        } else {\n            leftDivisors = sections(this._getGroupBys().rowGroupBys);\n            rightDivisors = [[groupBy]];\n        }\n        var divisors = cartesian(leftDivisors, rightDivisors);\n\n        delete group.type;\n        return this._subdivideGroup(group, divisors);\n    },\n    /**\n     * Export model data in a form suitable for an easy encoding of the pivot\n     * table in excell.\n     *\n     * @returns {Object}\n     */\n    exportData: function () {\n        var measureCount = this.data.measures.length;\n        var originCount = this.data.origins.length;\n\n        var table = this._getTable();\n\n        // process headers\n        var headers = table.headers;\n        var colGroupHeaderRows;\n        var measureRow = [];\n        var originRow = [];\n\n        function processHeader(header) {\n            var inTotalColumn = header.groupId[1].length === 0;\n            return {\n                title: header.title,\n                width: header.width,\n                height: header.height,\n                is_bold: !!header.measure && inTotalColumn\n            };\n        }\n\n        if (originCount > 1) {\n            colGroupHeaderRows = headers.slice(0, headers.length - 2);\n            measureRow = headers[headers.length - 2].map(processHeader);\n            originRow = headers[headers.length - 1].map(processHeader);\n        } else {\n            colGroupHeaderRows = headers.slice(0, headers.length - 1);\n            measureRow = headers[headers.length - 1].map(processHeader);\n        }\n\n        // remove the empty headers on left side\n        colGroupHeaderRows[0].splice(0, 1);\n\n        colGroupHeaderRows = colGroupHeaderRows.map(function (headerRow) {\n            return headerRow.map(processHeader);\n        });\n\n        // process rows\n        var tableRows = table.rows.map(function (row) {\n            return {\n                title: row.title,\n                indent: row.indent,\n                values: row.subGroupMeasurements.map(function (measurement) {\n                    var value = measurement.value;\n                    if (value === undefined) {\n                        value = \"\";\n                    } else if (measurement.originIndexes.length > 1) {\n                        // in that case the value is a variation and a\n                        // number between 0 and 1\n                        value = value * 100;\n                    }\n                    return {\n                        is_bold: measurement.isBold,\n                        value: value,\n                    };\n                }),\n            };\n        });\n\n        return {\n            col_group_headers: colGroupHeaderRows,\n            measure_headers: measureRow,\n            origin_headers: originRow,\n            rows: tableRows,\n            measure_count: measureCount,\n            origin_count: originCount,\n        };\n    },\n    /**\n     * Swap the pivot columns and the rows. It is a synchronous operation.\n     */\n    flip: function () {\n        // swap the data: the main column and the main row\n        var temp = this.rowGroupTree;\n        this.rowGroupTree = this.colGroupTree;\n        this.colGroupTree = temp;\n\n        // we need to update the record metadata: (expanded) row and col groupBys\n        temp = this.data.rowGroupBys;\n        this.data.groupedBy = this.data.colGroupBys;\n        this.data.rowGroupBys = this.data.colGroupBys;\n        this.data.colGroupBys = temp;\n        temp = this.data.expandedColGroupBys;\n        this.data.expandedColGroupBys = this.data.expandedRowGroupBys;\n        this.data.expandedRowGroupBys = temp;\n\n        function twistKey(key) {\n            return JSON.stringify(JSON.parse(key).reverse());\n        }\n\n        function twist(object) {\n            var newObject = {};\n            Object.keys(object).forEach(function (key) {\n                var value = object[key];\n                newObject[twistKey(key)] = value;\n            });\n            return newObject;\n        }\n\n        this.measurements = twist(this.measurements);\n        this.counts = twist(this.counts);\n        this.groupDomains = twist(this.groupDomains);\n    },\n    /**\n     * @override\n     *\n     * @param {Object} [options]\n     * @param {boolean} [options.raw=false]\n     * @returns {Object}\n     */\n    __get: function (options) {\n        options = options || {};\n        var raw = options.raw || false;\n        var groupBys = this._getGroupBys();\n        var state = {\n            colGroupBys: groupBys.colGroupBys,\n            context: this.data.context,\n            domain: this.data.domain,\n            fields: this.fields,\n            hasData: this._hasData(),\n            isSample: this.isSampleModel,\n            measures: this.data.measures,\n            origins: this.data.origins,\n            rowGroupBys: groupBys.rowGroupBys,\n            modelName: this.modelName\n        };\n        if (!raw && state.hasData) {\n            state.table = this._getTable();\n            state.tree = this.rowGroupTree;\n        }\n        return state;\n    },\n    /**\n     * Returns the total number of columns of the pivot table.\n     *\n     * @returns {integer}\n     */\n    getTableWidth: function () {\n        var leafCounts = this._getLeafCounts(this.colGroupTree);\n        return leafCounts[JSON.stringify(this.colGroupTree.root.values)] + 2;\n    },\n    /**\n     * @override\n     *\n     * @param {Object} params\n     * @param {boolean} [params.compare=false]\n     * @param {Object} params.context\n     * @param {Object} params.fields\n     * @param {string[]} [params.groupedBy]\n     * @param {string[]} params.colGroupBys\n     * @param {Array[]} params.domain\n     * @param {string[]} params.measures\n     * @param {string[]} params.rowGroupBys\n     * @param {string} [params.default_order]\n     * @param {string} params.modelName\n     * @param {Object} params.timeRanges\n     * @returns {Promise}\n     */\n    __load: function (params) {\n        this.initialDomain = params.domain;\n        this.initialRowGroupBys = params.context.pivot_row_groupby || params.rowGroupBys;\n        this.defaultGroupedBy = params.groupedBy;\n\n        this.fields = params.fields;\n        this.modelName = params.modelName;\n        const measures = this._processMeasures(params.context.pivot_measures) ||\n                            params.measures.map(m => m);\n        this.data = {\n            expandedRowGroupBys: [],\n            expandedColGroupBys: [],\n            domain: this.initialDomain,\n            context: _.extend({}, session.user_context, params.context),\n            groupedBy: params.context.pivot_row_groupby || params.groupedBy,\n            colGroupBys: params.context.pivot_column_groupby || params.colGroupBys,\n            measures,\n            timeRanges: params.timeRanges,\n        };\n        this._computeDerivedParams();\n\n        this.data.groupedBy = this.data.groupedBy.slice();\n        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();\n\n        var defaultOrder = params.default_order && params.default_order.split(' ');\n        if (defaultOrder) {\n            this.data.sortedColumn = {\n                groupId: [[], []],\n                measure: defaultOrder[0],\n                order: defaultOrder[1] ? defaultOrder [1] : 'asc',\n            };\n        }\n        return this._loadData();\n    },\n    /**\n     * @override\n     *\n     * @param {any} handle this parameter is ignored\n     * @param {Object} params\n     * @param {boolean} [params.compare=false]\n     * @param {Object} params.context\n     * @param {string[]} [params.groupedBy]\n     * @param {Array[]} params.domain\n     * @param {string[]} params.groupBy\n     * @param {string[]} params.measures\n     * @param {Object} [params.timeRanges]\n     * @returns {Promise}\n     */\n    __reload: function (handle, params) {\n        var self = this;\n        var oldColGroupBys = this.data.colGroupBys;\n        var oldRowGroupBys = this.data.rowGroupBys;\n        if ('context' in params) {\n            this.data.context = params.context;\n            this.data.colGroupBys = params.context.pivot_column_groupby || this.data.colGroupBys;\n            this.data.groupedBy = params.context.pivot_row_groupby || this.data.groupedBy;\n            this.data.measures = this._processMeasures(params.context.pivot_measures) || this.data.measures;\n            this.defaultGroupedBy = this.data.groupedBy.length ? this.data.groupedBy : this.defaultGroupedBy;\n        }\n        if ('domain' in params) {\n            this.data.domain = params.domain;\n            this.initialDomain = params.domain;\n        } else {\n            this.data.domain = this.initialDomain;\n        }\n        if ('groupBy' in params) {\n            this.data.groupedBy = params.groupBy.length ? params.groupBy : this.defaultGroupedBy;\n        }\n        if ('timeRanges' in params) {\n            this.data.timeRanges = params.timeRanges;\n        }\n        this._computeDerivedParams();\n\n        this.data.groupedBy = this.data.groupedBy.slice();\n        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();\n\n        if (!_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {\n            this.data.expandedRowGroupBys = [];\n        }\n        if (!_.isEqual(oldColGroupBys, self.data.colGroupBys)) {\n            this.data.expandedColGroupBys = [];\n        }\n\n        if ('measure' in params) {\n            return this._toggleMeasure(params.measure);\n        }\n\n        if (!this._hasData()) {\n            return this._loadData();\n        }\n\n        var oldRowGroupTree = this.rowGroupTree;\n        var oldColGroupTree = this.colGroupTree;\n        return this._loadData().then(function () {\n            if (_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {\n                self._pruneTree(self.rowGroupTree, oldRowGroupTree);\n            }\n            if (_.isEqual(oldColGroupBys, self.data.colGroupBys)) {\n                self._pruneTree(self.colGroupTree, oldColGroupTree);\n            }\n        });\n    },\n    /**\n     * Sort the rows, depending on the values of a given column.  This is an\n     * in-memory sort.\n     *\n     * @param {Object} sortedColumn\n     * @param {number[]} sortedColumn.groupId\n     */\n    sortRows: function (sortedColumn) {\n        var self = this;\n        var colGroupValues = sortedColumn.groupId[1];\n        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];\n        this.data.sortedColumn = sortedColumn;\n\n        var sortFunction = function (tree) {\n            return function (subTreeKey) {\n                var subTree = tree.directSubTrees.get(subTreeKey);\n                var groupIntersectionId = [subTree.root.values, colGroupValues];\n                var value = self._getCellValue(\n                    groupIntersectionId,\n                    sortedColumn.measure,\n                    sortedColumn.originIndexes\n                ) || 0;\n                return sortedColumn.order === 'asc' ? value : -value;\n            };\n        };\n\n        this._sortTree(sortFunction, this.rowGroupTree);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add labels/values in the provided groupTree. A new leaf is created in\n     * the groupTree with a root object corresponding to the group with given\n     * labels/values.\n     *\n     * @private\n     * @param {Object} groupTree, either this.rowGroupTree or this.colGroupTree\n     * @param {string[]} labels\n     * @param {Array} values\n     */\n    _addGroup: function (groupTree, labels, values) {\n        var tree = groupTree;\n        // we assume here that the group with value value.slice(value.length - 2) has already been added.\n        values.slice(0, values.length - 1).forEach(function (value) {\n            tree = tree.directSubTrees.get(value);\n        });\n        const value = values[values.length - 1];\n        if (tree.directSubTrees.has(value)) {\n            return;\n        }\n        tree.directSubTrees.set(value, {\n            root: {\n                labels: labels,\n                values: values,\n            },\n            directSubTrees: new Map(),\n        });\n    },\n    /**\n     * Compute what should be used as rowGroupBys by the pivot view\n     *\n     * @private\n     * @returns {string[]}\n     */\n    _computeRowGroupBys: function () {\n        return !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys;\n    },\n    /**\n     * Find a group with given values in the provided groupTree, either\n     * this.rowGrouptree or this.colGroupTree.\n     *\n     * @private\n     * @param  {Object} groupTree\n     * @param  {Array} values\n     * @returns {Object}\n     */\n    _findGroup: function (groupTree, values) {\n        var tree = groupTree;\n        values.slice(0, values.length).forEach(function (value) {\n            tree = tree.directSubTrees.get(value);\n        });\n        return tree;\n    },\n    /**\n     * In case originIndex is an array of length 1, thus a single origin\n     * index, returns the given measure for a group determined by the id\n     * groupId and the origin index.\n     * If originIndexes is an array of length 2, we compute the variation\n     * ot the measure values for the groups determined by groupId and the\n     * different origin indexes.\n     *\n     * @private\n     * @param  {Array[]} groupId\n     * @param  {string} measure\n     * @param  {number[]} originIndexes\n     * @returns {number}\n     */\n    _getCellValue: function (groupId, measure, originIndexes) {\n        var self = this;\n        var key = JSON.stringify(groupId);\n        if (!self.measurements[key]) {\n            return;\n        }\n        var values = originIndexes.map(function (originIndex) {\n            return self.measurements[key][originIndex][measure];\n        });\n        if (originIndexes.length > 1) {\n            return computeVariation(values[1], values[0]);\n        } else {\n            return values[0];\n        }\n    },\n    /**\n     * Returns the rowGroupBys and colGroupBys arrays that\n     * are actually used by the pivot view internally\n     * (for read_group or other purpose)\n     *\n     * @private\n     * @returns {Object} with keys colGroupBys and rowGroupBys\n     */\n    _getGroupBys: function () {\n        return {\n            colGroupBys: this.data.colGroupBys.concat(this.data.expandedColGroupBys),\n            rowGroupBys: this.data.rowGroupBys.concat(this.data.expandedRowGroupBys),\n        };\n    },\n    /**\n     * Returns a domain representation of a group\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {Array} group.colValues\n     * @param  {Array} group.rowValues\n     * @param  {number} group.originIndex\n     * @returns {Array[]}\n     */\n    _getGroupDomain: function (group) {\n        var key = JSON.stringify([group.rowValues, group.colValues]);\n        return this.groupDomains[key][group.originIndex];\n    },\n    /**\n     * Returns the group sanitized labels.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} groupBys\n     * @returns {string[]}\n     */\n    _getGroupLabels: function (group, groupBys) {\n        var self = this;\n        return groupBys.map(function (groupBy) {\n            return self._sanitizeLabel(group[groupBy], groupBy);\n        });\n    },\n    /**\n     * Returns a promise that returns the annotated read_group results\n     * corresponding to a partition of the given group obtained using the given\n     * rowGroupBy and colGroupBy.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} rowGroupBy\n     * @param  {string[]} colGroupBy\n     * @returns {Promise}\n     */\n    _getGroupSubdivision: function (group, rowGroupBy, colGroupBy) {\n        var groupDomain = this._getGroupDomain(group);\n        var measureSpecs = this._getMeasureSpecs();\n        var groupBy = rowGroupBy.concat(colGroupBy);\n        return this._rpc({\n            model: this.modelName,\n            method: 'read_group',\n            context: this.data.context,\n            domain: groupDomain,\n            fields: measureSpecs,\n            groupBy: groupBy,\n            lazy: false,\n        }).then(function (subGroups) {\n            return {\n                group: group,\n                subGroups: subGroups,\n                rowGroupBy: rowGroupBy,\n                colGroupBy: colGroupBy\n            };\n        });\n    },\n    /**\n     * Returns the group sanitized values.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} groupBys\n     * @returns {Array}\n     */\n    _getGroupValues: function (group, groupBys) {\n        var self = this;\n        return groupBys.map(function (groupBy) {\n            return self._sanitizeValue(group[groupBy]);\n        });\n    },\n    /**\n     * Returns the leaf counts of each group inside the given tree.\n     *\n     * @private\n     * @param {Object} tree\n     * @returns {Object} keys are group ids\n     */\n    _getLeafCounts: function (tree) {\n        var self = this;\n        var leafCounts = {};\n        var leafCount;\n        if (!tree.directSubTrees.size) {\n            leafCount = 1;\n        } else {\n            leafCount = [...tree.directSubTrees.values()].reduce(\n                function (acc, subTree) {\n                    var subLeafCounts = self._getLeafCounts(subTree);\n                    _.extend(leafCounts, subLeafCounts);\n                    return acc + leafCounts[JSON.stringify(subTree.root.values)];\n                },\n                0\n            );\n        }\n\n        leafCounts[JSON.stringify(tree.root.values)] = leafCount;\n        return leafCounts;\n    },\n    /**\n     * Returns the group sanitized measure values for the measures in\n     * this.data.measures (that migth contain '__count', not really a fieldName).\n     *\n     * @private\n     * @param  {Object} group\n     * @returns {Array}\n     */\n    _getMeasurements: function (group) {\n        var self = this;\n        return this.data.measures.reduce(\n            function (measurements, fieldName) {\n                var measurement = group[fieldName];\n                if (measurement instanceof Array) {\n                    // case field is many2one and used as measure and groupBy simultaneously\n                    measurement = 1;\n                }\n                if (self.fields[fieldName].type === 'boolean' && measurement instanceof Boolean) {\n                    measurement = measurement ? 1 : 0;\n                }\n                if (self.data.origins.length > 1 && !measurement) {\n                    measurement = 0;\n                }\n                measurements[fieldName] = measurement;\n                return measurements;\n            },\n            {}\n        );\n    },\n    /**\n     * Returns a description of the measures row of the pivot table\n     *\n     * @private\n     * @param {Object[]} columns for which measure cells must be generated\n     * @returns {Object[]}\n     */\n    _getMeasuresRow: function (columns) {\n        var self = this;\n        var sortedColumn = this.data.sortedColumn || {};\n        var measureRow = [];\n\n        columns.forEach(function (column) {\n            self.data.measures.forEach(function (measure) {\n                var measureCell = {\n                    groupId: column.groupId,\n                    height: 1,\n                    measure: measure,\n                    title: self.fields[measure].string,\n                    width: 2 * self.data.origins.length - 1,\n                };\n                if (sortedColumn.measure === measure &&\n                    _.isEqual(sortedColumn.groupId, column.groupId)) {\n                    measureCell.order = sortedColumn.order;\n                }\n                measureRow.push(measureCell);\n            });\n        });\n\n        return measureRow;\n    },\n    /**\n     * Returns the list of measure specs associated with data.measures, i.e.\n     * a measure 'fieldName' becomes 'fieldName:groupOperator' where\n     * groupOperator is the value specified on the field 'fieldName' for\n     * the key group_operator.\n     *\n     * @private\n     * @return {string[]}\n     */\n    _getMeasureSpecs: function () {\n        var self = this;\n        return this.data.measures.reduce(\n            function (acc, measure) {\n                if (measure === '__count') {\n                    acc.push(measure);\n                    return acc;\n                }\n                var type = self.fields[measure].type;\n                var groupOperator = self.fields[measure].group_operator;\n                if (type === 'many2one') {\n                    groupOperator = 'count_distinct';\n                }\n                if (groupOperator === undefined) {\n                    throw new Error(\"No aggregate function has been provided for the measure '\" + measure + \"'\");\n                }\n                acc.push(measure + ':' + groupOperator);\n                return acc;\n            },\n            []\n        );\n    },\n    /**\n     * Make sure that the labels of different many2one values are distinguished\n     * by numbering them if necessary.\n     *\n     * @private\n     * @param {Array} label\n     * @param {string} fieldName\n     * @returns {string}\n     */\n    _getNumberedLabel: function (label, fieldName) {\n        var id = label[0];\n        var name = label[1];\n        this.numbering[fieldName] = this.numbering[fieldName] || {};\n        this.numbering[fieldName][name] = this.numbering[fieldName][name] || {};\n        var numbers = this.numbering[fieldName][name];\n        numbers[id] = numbers[id] || _.size(numbers) + 1;\n        return name + (numbers[id] > 1 ? \"  (\" + numbers[id] + \")\" : \"\");\n    },\n    /**\n     * Returns a description of the origins row of the pivot table\n     *\n     * @private\n     * @param {Object[]} columns for which origin cells must be generated\n     * @returns {Object[]}\n     */\n    _getOriginsRow: function (columns) {\n        var self = this;\n        var sortedColumn = this.data.sortedColumn || {};\n        var originRow = [];\n\n        columns.forEach(function (column) {\n            var groupId = column.groupId;\n            var measure = column.measure;\n            var isSorted = sortedColumn.measure === measure &&\n                _.isEqual(sortedColumn.groupId, groupId);\n            var isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];\n            var isSortedByVariation = isSorted && sortedColumn.originIndexes[1];\n\n            self.data.origins.forEach(function (origin, originIndex) {\n                var originCell = {\n                    groupId: groupId,\n                    height: 1,\n                    measure: measure,\n                    originIndexes: [originIndex],\n                    title: origin,\n                    width: 1,\n                };\n                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {\n                    originCell.order = sortedColumn.order;\n                }\n                originRow.push(originCell);\n\n                if (originIndex > 0) {\n                    var variationCell = {\n                        groupId: groupId,\n                        height: 1,\n                        measure: measure,\n                        originIndexes: [originIndex - 1, originIndex],\n                        title: _t('Variation'),\n                        width: 1,\n                    };\n                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {\n                        variationCell.order = sortedColumn.order;\n                    }\n                    originRow.push(variationCell);\n                }\n\n            });\n        });\n\n        return originRow;\n    },\n\n    /**\n     * Returns a description of the pivot table.\n     *\n     * @private\n     * @returns {Object}\n     */\n    _getTable: function () {\n        var headers = this._getTableHeaders();\n        return {\n            headers: headers,\n            rows: this._getTableRows(this.rowGroupTree, headers[headers.length - 1]),\n        };\n    },\n    /**\n     * Returns the list of header rows of the pivot table: the col group rows\n     * (depending on the col groupbys), the measures row and optionnaly the\n     * origins row (if there are more than one origins).\n     *\n     * @private\n     * @returns {Object[]}\n     */\n    _getTableHeaders: function () {\n        var colGroupBys = this._getGroupBys().colGroupBys;\n        var height = colGroupBys.length + 1;\n        var measureCount = this.data.measures.length;\n        var originCount = this.data.origins.length;\n        var leafCounts = this._getLeafCounts(this.colGroupTree);\n        var headers = [];\n        var measureColumns = []; // used to generate the measure cells\n\n        // 1) generate col group rows (total row + one row for each col groupby)\n        var colGroupRows = (new Array(height)).fill(0).map(function () {\n            return [];\n        });\n        // blank top left cell\n        colGroupRows[0].push({\n            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]\n            title: \"\",\n            width: 1,\n        });\n\n        // col groupby cells with group values\n        /**\n         * Recursive function that generates the header cells corresponding to\n         * the groups of a given tree.\n         *\n         * @param {Object} tree\n         */\n        function generateTreeHeaders(tree, fields) {\n            var group = tree.root;\n            var rowIndex = group.values.length;\n            var row = colGroupRows[rowIndex];\n            var groupId = [[], group.values];\n            var isLeaf = !tree.directSubTrees.size;\n            var leafCount = leafCounts[JSON.stringify(tree.root.values)];\n            var cell = {\n                groupId: groupId,\n                height: isLeaf ? (colGroupBys.length + 1 - rowIndex) : 1,\n                isLeaf: isLeaf,\n                isFolded: isLeaf && colGroupBys.length > group.values.length,\n                label: rowIndex === 0 ? undefined : fields[colGroupBys[rowIndex - 1].split(':')[0]].string,\n                title: group.labels[group.labels.length - 1] || _t('Total'),\n                width: leafCount * measureCount * (2 * originCount - 1),\n            };\n            row.push(cell);\n            if (isLeaf) {\n                measureColumns.push(cell);\n            }\n\n            [...tree.directSubTrees.values()].forEach(function (subTree) {\n                generateTreeHeaders(subTree, fields);\n            });\n        }\n\n        generateTreeHeaders(this.colGroupTree, this.fields);\n        // blank top right cell for 'Total' group (if there is more that one leaf)\n        if (leafCounts[JSON.stringify(this.colGroupTree.root.values)] > 1) {\n            var groupId = [[], []];\n            var totalTopRightCell = {\n                groupId: groupId,\n                height: height,\n                title: \"\",\n                width: measureCount * (2 * originCount - 1),\n            };\n            colGroupRows[0].push(totalTopRightCell);\n            measureColumns.push(totalTopRightCell);\n        }\n        headers = headers.concat(colGroupRows);\n\n        // 2) generate measures row\n        var measuresRow = this._getMeasuresRow(measureColumns);\n        headers.push(measuresRow);\n\n        // 3) generate origins row if more than one origin\n        if (originCount > 1) {\n            headers.push(this._getOriginsRow(measuresRow));\n        }\n\n        return headers;\n    },\n    /**\n     * Returns the list of body rows of the pivot table for a given tree.\n     *\n     * @private\n     * @param {Object} tree\n     * @param {Object[]} columns\n     * @returns {Object[]}\n     */\n    _getTableRows: function (tree, columns) {\n        var self = this;\n\n        var rows = [];\n        var group = tree.root;\n        var rowGroupId = [group.values, []];\n        var title = group.labels[group.labels.length - 1] || _t('Total');\n        var indent = group.labels.length;\n        var isLeaf = !tree.directSubTrees.size;\n        var rowGroupBys = this._getGroupBys().rowGroupBys;\n\n        var subGroupMeasurements = columns.map(function (column) {\n            var colGroupId = column.groupId;\n            var groupIntersectionId = [rowGroupId[0], colGroupId[1]];\n            var measure = column.measure;\n            var originIndexes = column.originIndexes || [0];\n\n            var value = self._getCellValue(groupIntersectionId, measure, originIndexes);\n\n            var measurement = {\n                groupId: groupIntersectionId,\n                originIndexes: originIndexes,\n                measure: measure,\n                value: value,\n                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,\n            };\n            return measurement;\n        });\n\n        rows.push({\n            title: title,\n            label: indent === 0 ? undefined : this.fields[rowGroupBys[indent - 1].split(':')[0]].string,\n            groupId: rowGroupId,\n            indent: indent,\n            isLeaf: isLeaf,\n            isFolded: isLeaf && rowGroupBys.length > group.values.length,\n            subGroupMeasurements: subGroupMeasurements\n        });\n\n        var subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];\n        subTreeKeys.forEach(function (subTreeKey) {\n            var subTree = tree.directSubTrees.get(subTreeKey);\n            rows = rows.concat(self._getTableRows(subTree, columns));\n        });\n\n        return rows;\n    },\n    /**\n     * returns the height of a given groupTree\n     *\n     * @private\n     * @param  {Object} tree, a groupTree\n     * @returns {number}\n     */\n    _getTreeHeight: function (tree) {\n        var subTreeHeights = [...tree.directSubTrees.values()].map(this._getTreeHeight.bind(this));\n        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;\n    },\n    /**\n     * @private\n     * @returns {boolean}\n     */\n    _hasData: function () {\n        return (this.counts[JSON.stringify([[], []])] || []).some(function (count) {\n            return count > 0;\n        });\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        return !this._hasData();\n    },\n    /**\n     * Initilize/Reinitialize this.rowGroupTree, colGroupTree, measurements,\n     * counts and subdivide the group 'Total' as many times it is necessary.\n     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in\n     * order to see if there is data in the intersection of the group 'Total'\n     * and the various origins. In case there is none, nonsupplementary rpc\n     * will be done (see the code of subdivideGroup).\n     * Once the promise resolves, this.rowGroupTree, colGroupTree,\n     * measurements, counts are correctly set.\n     *\n     * @private\n     * @return {Promise}\n     */\n    _loadData: function () {\n        var self = this;\n\n        this.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        this.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        this.measurements = {};\n        this.counts = {};\n\n        var key = JSON.stringify([[], []]);\n        this.groupDomains = {};\n        this.groupDomains[key] = this.data.domains.slice(0);\n\n\n        var group = { rowValues: [], colValues: [] };\n        var groupBys = this._getGroupBys();\n        var leftDivisors = sections(groupBys.rowGroupBys);\n        var rightDivisors = sections(groupBys.colGroupBys);\n        var divisors = cartesian(leftDivisors, rightDivisors);\n\n        return this._subdivideGroup(group, divisors.slice(0, 1)).then(function () {\n            return self._subdivideGroup(group, divisors.slice(1));\n        });\n    },\n    /**\n     * Extract the information in the read_group results (groupSubdivisions)\n     * and develop this.rowGroupTree, colGroupTree, measurements, counts, and\n     * groupDomains.\n     * If a column needs to be sorted, the rowGroupTree corresponding to the\n     * group is sorted.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {Object[]} groupSubdivisions\n     */\n    _prepareData: function (group, groupSubdivisions) {\n        var self = this;\n\n        var groupRowValues = group.rowValues;\n        var groupRowLabels = [];\n        var rowSubTree = this.rowGroupTree;\n        var root;\n        if (groupRowValues.length) {\n            // we should have labels information on hand! regretful!\n            rowSubTree = this._findGroup(this.rowGroupTree, groupRowValues);\n            root = rowSubTree.root;\n            groupRowLabels = root.labels;\n        }\n\n        var groupColValues = group.colValues;\n        var groupColLabels = [];\n        if (groupColValues.length) {\n            root = this._findGroup(this.colGroupTree, groupColValues).root;\n            groupColLabels = root.labels;\n        }\n\n        groupSubdivisions.forEach(function (groupSubdivision) {\n            groupSubdivision.subGroups.forEach(function (subGroup) {\n\n                var rowValues = groupRowValues.concat(self._getGroupValues(subGroup, groupSubdivision.rowGroupBy));\n                var rowLabels = groupRowLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.rowGroupBy));\n\n                var colValues = groupColValues.concat(self._getGroupValues(subGroup, groupSubdivision.colGroupBy));\n                var colLabels = groupColLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.colGroupBy));\n\n                if (!colValues.length && rowValues.length) {\n                    self._addGroup(self.rowGroupTree, rowLabels, rowValues);\n                }\n                if (colValues.length && !rowValues.length) {\n                    self._addGroup(self.colGroupTree, colLabels, colValues);\n                }\n\n                var key = JSON.stringify([rowValues, colValues]);\n                var originIndex = groupSubdivision.group.originIndex;\n\n                if (!(key in self.measurements)) {\n                    self.measurements[key] = self.data.origins.map(function () {\n                        return self._getMeasurements({});\n                    });\n                }\n                self.measurements[key][originIndex] = self._getMeasurements(subGroup);\n\n                if (!(key in self.counts)) {\n                    self.counts[key] = self.data.origins.map(function () {\n                        return 0;\n                    });\n                }\n                self.counts[key][originIndex] = subGroup.__count;\n\n                if (!(key in self.groupDomains)) {\n                    self.groupDomains[key] = self.data.origins.map(function () {\n                        return Domain.FALSE_DOMAIN;\n                    });\n                }\n                // if __domain is not defined this means that we are in the\n                // case where\n                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []\n                if (subGroup.__domain) {\n                    self.groupDomains[key][originIndex] = subGroup.__domain;\n                }\n            });\n        });\n\n        if (this.data.sortedColumn) {\n            this.sortRows(this.data.sortedColumn, rowSubTree);\n        }\n    },\n    /**\n     * In the preview implementation of the pivot view (a.k.a. version 2),\n     * the virtual field used to display the number of records was named\n     * __count__, whereas __count is actually the one used in xml. So\n     * basically, activating a filter specifying __count as measures crashed.\n     * Unfortunately, as __count__ was used in the JS, all filters saved as\n     * favorite at that time were saved with __count__, and not __count.\n     * So in order the make them still work with the new implementation, we\n     * handle both __count__ and __count.\n     *\n     * This function replaces in the given array of measures occurences of\n     * '__count__' by '__count'.\n     *\n     * @private\n     * @param {Array[string] || undefined} measures\n     * @returns {Array[string] || undefined}\n     */\n    _processMeasures: function (measures) {\n        if (measures) {\n            return _.map(measures, function (measure) {\n                return measure === '__count__' ? '__count' : measure;\n            });\n        }\n    },\n    /**\n     * Determine this.data.domains and this.data.origins from\n     * this.data.domain and this.data.timeRanges;\n     *\n     * @private\n     */\n    _computeDerivedParams: function () {\n        const { range, rangeDescription, comparisonRange, comparisonRangeDescription } = this.data.timeRanges;\n        if (range) {\n            this.data.domains = [this.data.domain.concat(comparisonRange), this.data.domain.concat(range)];\n            this.data.origins = [comparisonRangeDescription, rangeDescription];\n        } else {\n            this.data.domains = [this.data.domain];\n            this.data.origins = [\"\"];\n        }\n    },\n    /**\n     * Make any group in tree a leaf if it was a leaf in oldTree.\n     *\n     * @private\n     * @param {Object} tree\n     * @param {Object} oldTree\n     */\n    _pruneTree: function (tree, oldTree) {\n        if (!oldTree.directSubTrees.size) {\n            tree.directSubTrees.clear();\n            delete tree.sortedKeys;\n            return;\n        }\n        var self = this;\n        [...tree.directSubTrees.keys()].forEach(function (subTreeKey) {\n            var subTree = tree.directSubTrees.get(subTreeKey);\n            if (!oldTree.directSubTrees.has(subTreeKey)) {\n                subTree.directSubTrees.clear();\n                delete subTreeKey.sortedKeys;\n            } else {\n                var oldSubTree = oldTree.directSubTrees.get(subTreeKey);\n                self._pruneTree(subTree, oldSubTree);\n            }\n        });\n    },\n    /**\n     * Toggle the active state for a given measure, then reload the data\n     * if this turns out to be necessary.\n     *\n     * @param {string} fieldName\n     * @returns {Promise}\n     */\n    _toggleMeasure: function (fieldName) {\n        var index = this.data.measures.indexOf(fieldName);\n        if (index !== -1) {\n            this.data.measures.splice(index, 1);\n            // in this case, we already have all data in memory, no need to\n            // actually reload a lesser amount of information\n            return Promise.resolve();\n        } else {\n            this.data.measures.push(fieldName);\n        }\n        return this._loadData();\n    },\n    /**\n     * Extract from a groupBy value a label.\n     *\n     * @private\n     * @param  {any} value\n     * @param  {string} groupBy\n     * @returns {string}\n     */\n    _sanitizeLabel: function (value, groupBy) {\n        var fieldName = groupBy.split(':')[0];\n        if (value === false) {\n            return _t(\"Undefined\");\n        }\n        if (value instanceof Array) {\n            return this._getNumberedLabel(value, fieldName);\n        }\n        if (fieldName && this.fields[fieldName] && (this.fields[fieldName].type === 'selection')) {\n            var selected = _.where(this.fields[fieldName].selection, { 0: value })[0];\n            return selected ? selected[1] : value;\n        }\n        return value;\n    },\n    /**\n     * Extract from a groupBy value the raw value of that groupBy (discarding\n     * a label if any)\n     *\n     * @private\n     * @param {any} value\n     * @returns {any}\n     */\n    _sanitizeValue: function (value) {\n        if (value instanceof Array) {\n            return value[0];\n        }\n        return value;\n    },\n    /**\n     * Get all partitions of a given group using the provided list of divisors\n     * and enrich the objects of this.rowGroupTree, colGroupTree,\n     * measurements, counts.\n     *\n     * @private\n     * @param {Object} group\n     * @param {Array[]} divisors\n     * @returns\n     */\n    _subdivideGroup: function (group, divisors) {\n        var self = this;\n\n        var key = JSON.stringify([group.rowValues, group.colValues]);\n\n        var proms = this.data.origins.reduce(\n            function (acc, origin, originIndex) {\n                // if no information on group content is available, we fetch data.\n                // if group is known to be empty for the given origin,\n                // we don't need to fetch data fot that origin.\n                if (!self.counts[key] || self.counts[key][originIndex] > 0) {\n                    var subGroup = {\n                        rowValues: group.rowValues,\n                        colValues: group.colValues,\n                        originIndex: originIndex\n                    };\n                    divisors.forEach(function (divisor) {\n                        acc.push(self._getGroupSubdivision(subGroup, divisor[0], divisor[1]));\n                    });\n                }\n                return acc;\n            },\n            []\n        );\n        return this._loadDataDropPrevious.add(Promise.all(proms)).then(function (groupSubdivisions) {\n            if (groupSubdivisions.length) {\n                self._prepareData(group, groupSubdivisions);\n            }\n        });\n    },\n    /**\n     * Sort recursively the subTrees of tree using sortFunction.\n     * In the end each node of the tree has its direct children sorted\n     * according to the criterion reprensented by sortFunction.\n     *\n     * @private\n     * @param  {Function} sortFunction\n     * @param  {Object} tree\n     */\n    _sortTree: function (sortFunction, tree) {\n        var self = this;\n        tree.sortedKeys = _.sortBy([...tree.directSubTrees.keys()], sortFunction(tree));\n        [...tree.directSubTrees.values()].forEach(function (subTree) {\n            self._sortTree(sortFunction, subTree);\n        });\n    },\n});\n\nexport default PivotModel;\n", "/** @odoo-module alias=web.PivotRenderer **/\n\n    import { useEffect } from \"@web/core/utils/hooks\";\n    import OwlAbstractRenderer from '../abstract_renderer_owl';\n    import field_utils from 'web.field_utils';\n    import { DEFAULT_INTERVAL, INTERVAL_OPTIONS, getIntervalOptions } from 'web.searchUtils';\n\n    const { Component, hooks } = owl;\n    const { useExternalListener, useState } = hooks;\n\n    class PivotCustomGroupByItem extends Component {\n        constructor() {\n            super(...arguments);\n            this.canBeOpened = true;\n            this.state = useState({ fieldName: this.props.fields[0].name });\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @private\n         */\n        onApply() {\n            const { fieldName } = this.state;\n            const { type } = this.props.fields.find(f => f.name === fieldName);\n            let interval = null;\n            if (['date', 'datetime'].includes(type)) {\n                interval = DEFAULT_INTERVAL;\n            }\n            this.trigger('groupby-menu-selection', { fieldName, interval, custom: true });\n            this.state.open = false;\n        }\n    }\n\n    PivotCustomGroupByItem.template = \"web.CustomGroupByItem\";\n    PivotCustomGroupByItem.props = { fields: Array };\n\n    export class PivotGroupByMenu extends Component {\n\n        constructor() {\n            super(...arguments);\n            this.intervalOptions = INTERVAL_OPTIONS;\n            this.openedSubMenus = {};\n        }\n\n        //---------------------------------------------------------------------\n        // Getters\n        //---------------------------------------------------------------------\n\n        /**\n         * @override\n         */\n        get items() {\n            let items = this.props.fields;\n            if (this.props.hasSearchArchGroupBys) {\n                items = this.props.searchModel.get('filters', f => f.type === 'groupBy');\n                let groupNumber = 1 + Math.max(...items.map(g => g.groupNumber), 0);\n                for (const [_, customGroupBy] of this.props.customGroupBys) {\n                    customGroupBy.groupNumber = groupNumber++;\n                    items.push(customGroupBy);\n                }\n            }\n            return items.map((item) => ({\n                ...item,\n                id: item.id || item.name,\n                fieldName: item.fieldName || item.name,\n                description: item.description || item.string,\n                isActive: false,\n                options:\n                    item.options || [\"date\", \"datetime\"].includes(item.type)\n                        ? getIntervalOptions()\n                        : undefined,\n            }));\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @param {string} fieldName\n         * @param {string|null} interval\n        */\n        _onClickMenuGroupBy(fieldName, interval) {\n            this.trigger('groupby-menu-selection', { fieldName, interval });\n        }\n\n        _toggleMenu(id) {\n            this.openedSubMenus[id] = !this.openedSubMenus[id];\n            this.render();\n        }\n    }\n\n    PivotGroupByMenu.template = \"web.legacy.PivotGroupByMenu\";\n    PivotGroupByMenu.components = { PivotCustomGroupByItem };\n    PivotGroupByMenu.props = {\n        customGroupBys: Map,\n        fields: Object,\n        hasSearchArchGroupBys: Boolean,\n        searchModel: true,\n    };\n\n    /**\n     * Here is a basic example of the structure of the Pivot Table:\n     *\n     * \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     * \u2502                         \u2502 - web.PivotHeader                           \u2502                 \u2502\n     * \u2502                         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                 \u2502\n     * \u2502                         \u2502 + web.PivotHeader    \u2502 + web.PivotHeader    \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502                         \u2502 web.PivotMeasure     \u2502 web.PivotMeasure     \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502 \u2500 web.PivotHeader       \u2502                      \u2502                      \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502    + web.PivotHeader    \u2502                      \u2502                      \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502    + web.PivotHeader    \u2502                      \u2502                      \u2502                 \u2502\n     * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     *\n     */\n\n    class PivotRenderer extends OwlAbstractRenderer {\n        /**\n         * @override\n         * @param {boolean} props.disableLinking Disallow opening records by clicking on a cell\n         * @param {Object} props.widgets Widgets defined in the arch\n         */\n        constructor() {\n            super(...arguments);\n            this.sampleDataTargets = ['table'];\n            this.state = useState({\n                activeNodeHeader: {\n                    groupId: false,\n                    isXAxis: false,\n                    click: false\n                },\n            });\n\n            const searchArchGroupBys = this.props.searchModel.get(\n                'filters',\n                f => f.type === 'groupBy' && !f.custom\n            );\n            // searchArchGroupBys is not an array when the control panel model\n            // extension is not installed (e.g. in an embedded pivot view)\n            this.hasSearchArchGroupBys = Boolean(searchArchGroupBys && searchArchGroupBys.length);\n            this.customGroupBys = new Map();\n\n            useEffect(() => this._updateTooltip());\n            useExternalListener(window, 'click', this._resetState);\n        }\n\n        //----------------------------------------------------------------------\n        // Private\n        //----------------------------------------------------------------------\n\n        /**\n         * Get the formatted value of the cell\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {string} Formatted value\n         */\n        _getFormattedValue(cell) {\n            const type = this.props.widgets[cell.measure] ||\n                (this.props.fields[cell.measure].type === 'many2one' ? 'integer' : this.props.fields[cell.measure].type);\n            const formatter = field_utils.format[type];\n            return formatter(cell.value, this.props.fields[cell.measure]);\n        }\n\n        /**\n         * Get the formatted variation of a cell\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {string} Formatted variation\n         */\n        _getFormattedVariation(cell) {\n            const value = cell.value;\n            return isNaN(value) ? '-' : field_utils.format.percentage(value, this.props.fields[cell.measure]);\n        }\n\n        /**\n         * Retrieves the padding of a left header\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {Number} Padding\n         */\n        _getPadding(cell) {\n            return 5 + cell.indent * 30;\n        }\n\n        /**\n         * Reset the state of the node.\n         *\n         * @private\n         */\n        _resetState() {\n            // This check is used to avoid the destruction of the dropdown.\n            // The click on the header bubbles to window in order to hide\n            // all the other dropdowns (in this component or other components).\n            // So we need isHeaderClicked to cancel this behaviour.\n            if (this.isHeaderClicked) {\n                this.isHeaderClicked = false;\n                return;\n            }\n            this.state.activeNodeHeader = {\n                groupId: false,\n                isXAxis: false,\n                click: false\n            };\n        }\n\n        /**\n         * Configure the tooltips on the headers.\n         *\n         * @private\n         */\n        _updateTooltip() {\n            $(this.el).find('.o_pivot_header_cell_opened, .o_pivot_header_cell_closed').tooltip();\n        }\n\n        //----------------------------------------------------------------------\n        // Handlers\n        //----------------------------------------------------------------------\n\n        /**\n         * @private\n         * @param {OwlEvent} ev\n         */\n        _onGroupByMenuSelection(ev) {\n            if (this.hasSearchArchGroupBys) {\n                const { custom, fieldName } = ev.detail;\n                if (custom && !this.customGroupBys.has(fieldName)) {\n                    const field = this.props.groupableFields.find(g => g.fieldName === fieldName)\n                    this.customGroupBys.set(fieldName, field);\n                }\n            }\n        }\n\n        /**\n         * Handles a click on a header node\n         *\n         * @private\n         * @param {Object} cell\n         * @param {string} type col or row\n         */\n        _onHeaderClick(cell, type) {\n            const groupValues = cell.groupId[type === 'col' ? 1 : 0];\n            const groupByLength = type === 'col' ? this.props.colGroupBys.length : this.props.rowGroupBys.length;\n            if (cell.isLeaf && groupValues.length >= groupByLength) {\n                this.isHeaderClicked = true;\n                this.state.activeNodeHeader = {\n                    groupId: cell.groupId,\n                    isXAxis: type === 'col',\n                    click: 'leftClick'\n                };\n            }\n            this.trigger(cell.isLeaf ? 'closed_header_click' : 'opened_header_click', { cell, type });\n        }\n\n        /**\n         * Hover the column in which the mouse is.\n         *\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onMouseEnter(ev) {\n            var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);\n            if (ev.currentTarget.tagName === 'TH') {\n                index += 1;\n            }\n            this.el.querySelectorAll('td:nth-child(' + (index + 1) + ')').forEach(elt => elt.classList.add('o_cell_hover'));\n        }\n\n        /**\n         * Remove the hover on the columns.\n         *\n         * @private\n         */\n        _onMouseLeave() {\n            this.el.querySelectorAll('.o_cell_hover').forEach(elt => elt.classList.remove('o_cell_hover'));\n        }\n    }\n\n    PivotRenderer.template = 'web.legacy.PivotRenderer';\n    PivotRenderer.components = { PivotGroupByMenu };\n\n    export default PivotRenderer;\n", "/** @odoo-module alias=web.PivotView **/\n\n    /**\n     * The Pivot View is a view that represents data in a 'pivot grid' form. It\n     * aggregates data on 2 dimensions and displays the result, allows the user to\n     * 'zoom in' data.\n     */\n\n    import AbstractView from '../abstract_view';\n    import config from 'web.config';\n    import core from 'web.core';\n    import PivotModel from 'web.PivotModel';\n    import PivotController from 'web.PivotController';\n    import PivotRenderer from './pivot_renderer';\n    import RendererWrapper from 'web.RendererWrapper';\n    import { sortBy } from 'web.utils';\n    import viewRegistry from \"web.view_registry\";\n\n    const _t = core._t;\n    const _lt = core._lt;\n\n    import * as searchUtils from 'web.searchUtils';\n    const GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;\n\n    const PivotView = AbstractView.extend({\n        display_name: _lt('Pivot'),\n        icon: 'fa-table',\n        config: Object.assign({}, AbstractView.prototype.config, {\n            Model: PivotModel,\n            Controller: PivotController,\n            Renderer: PivotRenderer,\n        }),\n        viewType: 'pivot',\n        searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],\n\n        /**\n         * @override\n         * @param {Object} params\n         * @param {Array} params.additionalMeasures\n         */\n        init: function (viewInfo, params) {\n            this._super.apply(this, arguments);\n\n            const activeMeasures = []; // Store the defined active measures\n            const colGroupBys = []; // Store the defined group_by used on cols\n            const rowGroupBys = []; // Store the defined group_by used on rows\n            const measures = {}; // All the available measures\n            const groupableFields = {}; // The fields which can be used to group data\n            const widgets = {}; // Wigdets defined in the arch\n            const additionalMeasures = params.additionalMeasures || [];\n\n            this.fields.__count = { string: _t(\"Count\"), type: \"integer\" };\n\n            //Compute the measures and the groupableFields\n            Object.keys(this.fields).forEach(name => {\n                const field = this.fields[name];\n                if (name !== 'id' && field.store === true) {\n                    if (['integer', 'float', 'monetary'].includes(field.type) || additionalMeasures.includes(name)) {\n                        measures[name] = field;\n                    }\n                    if (GROUPABLE_TYPES.includes(field.type)) {\n                        groupableFields[name] = Object.assign({\n                            description: field.string,\n                            fieldName: name,\n                            fieldType: field.type,\n                            name,\n                        }, field);\n                    }\n                }\n            });\n            measures.__count = { string: _t(\"Count\"), type: \"integer\" };\n\n\n            this.arch.children.forEach(field => {\n                let name = field.attrs.name;\n                // Remove invisible fields from the measures if not in additionalMeasures\n                if (field.attrs.invisible && py.eval(field.attrs.invisible)) {\n                    if (name in groupableFields) {\n                        delete groupableFields[name];\n                    }\n                    if (!additionalMeasures.includes(name)) {\n                        delete measures[name];\n                        return;\n                    }\n                }\n                if (field.attrs.interval) {\n                    name += ':' + field.attrs.interval;\n                }\n                if (field.attrs.widget) {\n                    widgets[name] = field.attrs.widget;\n                }\n                // add active measures to the measure list.  This is very rarely\n                // necessary, but it can be useful if one is working with a\n                // functional field non stored, but in a model with an overrided\n                // read_group method.  In this case, the pivot view could work, and\n                // the measure should be allowed.  However, be careful if you define\n                // a measure in your pivot view: non stored functional fields will\n                // probably not work (their aggregate will always be 0).\n                if (field.attrs.type === 'measure' && !(name in measures)) {\n                    measures[name] = this.fields[name];\n                }\n                if (field.attrs.string && name in measures) {\n                    measures[name].string = field.attrs.string;\n                }\n                if (field.attrs.type === 'measure' || 'operator' in field.attrs) {\n                    activeMeasures.push(name);\n                    measures[name] = this.fields[name];\n                }\n                if (field.attrs.type === 'col') {\n                    colGroupBys.push(name);\n                }\n                if (field.attrs.type === 'row') {\n                    rowGroupBys.push(name);\n                }\n            });\n            if ((!activeMeasures.length) || this.arch.attrs.display_quantity) {\n                activeMeasures.splice(0, 0, '__count');\n            }\n\n            this.loadParams.measures = activeMeasures;\n            this.loadParams.colGroupBys = config.device.isMobile ? [] : colGroupBys;\n            this.loadParams.rowGroupBys = rowGroupBys;\n            this.loadParams.fields = this.fields;\n            this.loadParams.default_order = params.default_order || this.arch.attrs.default_order;\n\n            const disableLinking = !!(this.arch.attrs.disable_linking &&\n                                        JSON.stringify(this.arch.attrs.disable_linking));\n\n            this.rendererParams.widgets = widgets;\n            this.rendererParams.disableLinking = disableLinking;\n            const { searchModel } = this.controllerParams;\n            this.rendererParams.searchModel = searchModel;\n            this.rendererParams.groupableFields = sortBy(Object.values(groupableFields), (f) => f.description);\n\n            this.controllerParams.disableLinking = disableLinking;\n            this.controllerParams.title = params.title || this.arch.attrs.string || _t(\"Untitled\");\n            this.controllerParams.measures = measures;\n\n            // retrieve form and list view ids from the action to open those views\n            // when a data cell of the pivot view is clicked\n            this.controllerParams.views = [\n                _findView(params.actionViews, 'list'),\n                _findView(params.actionViews, 'form'),\n            ];\n\n            function _findView(views, viewType) {\n                const view = views.find(view => {\n                    return view.type === viewType;\n                });\n                return [view ? view.viewID : false, viewType];\n            }\n        },\n\n        /**\n         *\n         * @override\n         */\n        getRenderer(parent, state) {\n            state = Object.assign(state || {}, this.rendererParams);\n            return new RendererWrapper(parent, this.config.Renderer, state);\n        },\n    });\n    viewRegistry.add(\"pivot\", PivotView);\n\n    export default PivotView;\n"], "file": "/web/assets/9429-bcac86c/web.assets_backend_legacy_lazy.js", "sourceRoot": "../../../"}